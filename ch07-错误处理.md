# 错误处理(Error Handling)

> 我早就知道无论我活多久,这种事情迟早总会发生的
> --George Bernard Shaw on dying

原文
> I knew if I stayed around long enough, something like this would happen

Rust中的错误处理与其自身的简短章节不同.这里没有任何困难的想法,只是对你来说可能不熟悉.本章介绍Rust中的两种不同类型的错误处理:panic和`Result`.

使用`Result`处理普通错误.这些通常是由程序外的事情引起的,例如错误的输入,网络中断或权限问题.发生这种情况并不取决于我们;即使是无错误的程序也会不时遇到它们.本章的大部分内容都是针对这种错误的.不过,我们会介绍panic,因为它更简单.

panic是针对另一种错误,那种 *不应该发生(should never happen)* 的错误.

## Panic

一个程序在遇到一些非常混乱的事情时会恐慌(panics),程序本身一定存在错误.就像是:

- 数组访问越界

- 整数除以零

- 在碰巧为`None`的`Option`上调用`.unwrap()`

- 断言失败

(还有宏`panic!()`,对于你自己的代码发现它出错的情况,你因此需要直接触发panic.`panic!()`接受可选的`println!()`式参数,用于构建错误信息.)

这些条件的共同之处在于它们都是--不够细致--程序员的错误.一个好的经验法则是:"Don't panic".

但我们都会犯错.当这些不该发生的错误确实发生了--然后呢?值得注意的是,Rust给了你一个选择.当发生恐慌时,Rust可以展开堆栈,也可以中止进程.展开是默认的.

### 展开(Unwinding)

当海盗瓜分从突袭中所得战利品时,船长获得了一半的战利品.普通船员获得另一半的平等份额.(海盗讨厌分数，所以如果任何一个分裂都没有出现,结果会向下舍入,其余部分将归船上的鹦鹉.)

```Rust
fn pirate_share(total: u64, crew_size: usize) -> u64 {
    let half = total / 2;
    half / crew_size as u64
}
```

这种情况可能会持续几个世纪,直到有一天发现船长是突袭的唯一幸存者.如果我们将一个为零的crew_size传递给这个函数,它将除以零.在C++中,这将是未定义行为.在Rust中,它会引发恐慌(panic),通常如下所示进行:

- 将错误消息打印到终端:

```Rust
thread 'main' panicked at 'attempt to divide by zero', pirates.rs:3780
note: Run with `RUST_BACKTRACE=1` for a backtrace.
```

如果设置`RUST_BACKTRACE`环境变量,正如消息所示,Rust也会在此时转储堆栈.

- 堆栈已解开.这很像C++异常处理.

当前函数正在使用的任何临时值,局部变量或参数将按照与创建它们相反的顺序顺序被删除.删除值只是意味着在它之后进行清理:程序使用的任何`String`或`Vec`都被释放,任何打开的`File`都被关闭,等等.也调用用户定义的`drop`方法;请参阅第282页的"Drop".在`pirate_share()`的特定情况下,没有什么可以清理的.

清除当前函数调用后,我们继续它的调用者,以相同的方式删除它的变量和参数.然后 *这个(that)* 函数的调用者,依此类推.

- 最后,线程退出.如果恐慌线程是主线程,则整个进程退出(使用非零退出代码).

也许 *恐慌(panic)* 是这个有序过程的误导性名称.恐慌不是崩溃.这不是未定义行为.它更像是Java中的`RuntimeException`或C++中的`std::logic_error`.行为是定义明确的;它不应该发生.

恐慌是安全的.它不违反Rust的任何安全规则;即使你在标准库方法的中间设法恐慌,它也永远不会在内存中留下悬空指针或半初始值.我们的想法是,在发生任何不良事件 *之前(before)* ,Rust会捕获无效的数组访问,或者不管它是什么.继续进行是不安全的,所以Rust解开了堆栈.但其余的过程可以继续运行.

每个线程都有恐慌.一个线程可能会恐慌,而其他线程正在进行正常业务.在第19章中,我们将展示父线程如何在子线程发生恐慌时找出它并优雅地处理错误.

还有一种方法可以捕获堆栈展开,允许线程存活并继续运行.标准库函数`std::panic::catch_unwind()`就是这样做的.我们不会介绍如何使用它,但这是Rust的测试线程在测试中断言失败时恢复的机制.(在编写可以从C或C++调用的Rust代码时,也有必要这样做,因为跨非Rust代码中展开是未定义行为;请参阅第21章.)

理想情况下,我们都将拥有永不恐慌的无错误代码.但没有人是完美的.你可以使用线程和`catch_unwind()`来处理恐慌,使你的程序更加健壮.一个重要的警告是,这些工具只能捕获展开堆栈的恐慌.并非每次恐慌都是这样进行的.

### 中止(Aborting)

堆栈展开是默认的恐慌行为,但有两种情况下Rust不会尝试展开堆栈.

如果在第一次恐慌之后一个`.drop()`方法触发第二次恐慌而Rust仍在尝试清理,这被认为是致命的.Rust停止展开并中止整个过程.

此外,Rust的恐慌行为是可定制的.如果使用`-C panic = abort`进行编译,程序中的 *第一个(first)* 恐慌会立即中止该过程.(使用此选项,Rust不需要知道如何展开堆栈,因此这可以减少编译完的代码的大小).

这就结束了我们对Rust的恐慌的讨论.没有太多可说的,因为普通的Rust代码没有义务处理恐慌.即使你使用线程或`catch_unwind()`,所有恐慌处理代码也可能集中在少数几个地方.期望程序中的每个函数都能预测并处理自己代码中的错误是不合理的.其他因素造成的错误是另一个严重的问题.

## Result(Result)

Rust没有异常.相反,可能失败的函数有一个返回类型,如下所示:

```Rust
fn get_weather(location: LatLng) -> Result<WeatherReport, io::Error>
```

`Result`类型表示可能的失败.当我们调用`get_weather()`函数时,它将返回 *成功结果(success result)* `Ok(weather)`,`weather`是一个新的`WeatherReport`值,或返回 *错误结果(error result)* ,`Err(error_value)`,其中`error_value`是一个`io::Error`解释出了什么错.

Rust要求我们在调用此函数时编写某种错误处理.我们无法在没有对`Result`做 *某些(something)* 事情的情况下获得`WeatherReport`,如果未使用`Result`值,你将收到编译器警告.

在第10章中,我们将看到标准库如何定义`Result`以及如何定义自己的类似类型.现在,我们将采用"烹饪手册(cookbook)"方法,并专注于如何使用`Result`来获得你想要的错误处理行为.

### 捕获错误(Catching Errors)

处理`Result`的最彻底的方法是我们在第2章中展示的方式:使用`match`表达式.

```Rust
match get_weather(hometown) {
    Ok(report) => {display_weather(hometown, &report);
    }
    Err(err) => {
        println!("error querying the weather: {}", err);
        schedule_weather_retry();
    }
}
```

这是Rust相当于其他语言的`try/catch`.这是你想要正面处理错误时使用的,而不是将它们传递给你的调用者.

`match`有点冗长,因此`Result<T, E>`提供了各种在特殊情况下有用的方法.这些方法中的每一个在其实现中都具有`match`表达式.(有关结果方法的完整列表,请参阅在线文档.此处列出的方法是我们最常用的方法.)

- `result.is_ok()`和`result.is_err()`返回一个`bool`,告诉结果是成功结果还是错误结果.

- `result.ok()`返回成功值(如果有)作为`Option<T>`.如果`result`是成功结果,则返回`Some(success_value)`;否则,它返回`None`,丢弃错误值.

- `result.err()`返回错误值(如果有),作为`Option<E>`.

- `result.unwrap_or(fallback)`返回成功值,如果`result`是成功结果.否则,它返回`fallback`,丢弃错误值.

```Rust
// A fairly safe prediction for Southern California.
const THE_USUAL: WeatherReport = WeatherReport::Sunny(72);

// Get a real weather report, if possible.
// If not, fall back on the usual.
let report = get_weather(los_angeles).unwrap_or(THE_USUAL);
display_weather(los_angeles, &report);
```

这是`.ok()`的一个很好的替代方法,因为返回类型是`T`,而不是`Option<T>`.当然,只有在有适当的后备值时它才有效.

- `result.unwrap_or_else(fallback_fn)`是相同的,但不是直接传递一个后备值,而是传递一个函数或闭包.这适用于如果你不打算使用它来计算后备值会浪费的情况.仅当我们有错误结果时才会调用`fallback_fn`.

```Rust
let report =
    get_weather(hometown)
    .unwrap_or_else(|_err| vague_prediction(hometown));
```

(第14章详细介绍闭包)

- `result.unwrap()`也返回成功值,如果`result`是成功结果.但是,如果`result`是错误结果,则此方法会发生恐慌.这种方法有其用途;我们稍后会详细讨论它.

- `result.expect(message)`与`.unwrap()`相同,但允许你提供在出现恐慌情况时打印的消息.

最后,有两种方法可以借用对Result中值的引用:

- `result.as_ref()`将`Result<T, E>`转换为`Result<&T, &E>`,借用对现有结果中成功或错误值的引用.

- `result.as_mut()`是相同的,但借用了一个可变引用.返回类型是`Result<&mut T, &mut E>`.

这两个方法最有用的一个原因是此处列出的所有其他方法(`.is_ok()`和`.is_err()`除外)都会 *消耗(consume)* 它们操作的`result`.也就是说,他们通过值来接受`self`参数.有时在不破坏结果的情况下访问结果中的数据非常方便,这就是`.as_ref()`和`.as_mut()`为我们做的事情.

例如,假设你想调用`result.ok()`,但你需要将结果保持原样.你可以编写`result.as_ref().ok()`,它只是借用结果,返回`Option<&T>`而不是`Option<T>`.

### Result类型别名(Result Type Aliases)

有时你会看到Rust文档似乎省略了`Result`的错误类型:

```Rust
fn remove_file(path: &Path) -> Result<()>
```

这意味着正在使用`Result`类型别名.

类型别名是类型名称的一种简写.模块通常定义`Result`类型别名,以避免重复模块中几乎每个函数使用一致的错误类型.例如,标准库的`std::io`模块包含以下代码行:

```Rust
pub type Result<T> = result::Result<T, Error>;
```

这定义了一个公开类型`std::io::Result<T>`.它是`Result<T, E>`的别名,但硬编码`std::io::Error`作为错误类型.实际上,这意味着如果你编写`use std::io`;然后Rust会将`io::Result<String>`理解为`Result<String, io::Error>`的简写.

当在线文档中出现`Result<()>`之类的内容时,你可以单击标识符`Result`来查看正在使用的类型别名并了解错误类型.在实践中,它通常从上下文中显而易见.

### 打印错误(Printing Errors)