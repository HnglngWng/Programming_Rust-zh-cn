# 不安全代码(Unsafe Code)

> 不要有人认为我软弱无能,温良恭顺;
> 我恰好是另外一种女人:
> 我对仇人很强暴,对朋友却很温和,
> 要像我这样的为人才算光荣.
> --欧里庇得斯, <美狄亚>

原文

> Let no one think of me that I am humble or weak or passive;
> Let them understand I am of a different kind:
> dangerous to my enemies, loyal to my friends.
> To such a life glory belongs.
> --Euripides, Medea

系统编程的秘密乐趣在于,在每一种安全语言和精心设计的抽象之下,都是一种旋转的漩涡,这种漩涡是一种非常不安全的机器语言和小巧的混乱.你也可以在Rust写这个.

我们在本书中提到的语言通过类型,生命周期,边界检查等确保您的程序完全自动地没有内存错误和数据竞争.但这种自动推理有其局限性;有许多有价值的技术,Rust无法识别它们是安全的.

*不安全代码(Unsafe code)* 让你告诉Rust,"在这种情况下,请相信我(In this case, just trust me)."通过标记一个块或函数为不安全,你获得了调用标准库中`unsafe`函数,解引用不安全指针和调用其他语言(像C和C++)的函数的能力,以及其他权力.Rust的所有常规安全检查仍然适用:类型检查,生命周期检查和索引的边界检查都会正常发生.不安全代码只能启用一小组附加功能.

这种跨越安全Rust边界的能力使得在Rust中实现Rust的许多最基本功能成为可能,就像在C和C++系统中一样.不安全代码允许`Vec`类型有效地管理其缓冲区;`std::io`模块与操作系统通信;和`std::thread`和`std::sync`模块提供并发原语.

本章介绍了使用不安全功能的基本要点:

- Rust的`unsafe`块在普通的,安全的Rust代码和使用不安全功能的代码之间建立了界限.

- 你可以将函数标记为`unsafe`,提醒调用者他们必须遵守的额外合同,以避免未定义行为.

- 原始指针及其方法允许无限制地访问内存,并允许你构建数据结构,非不安全代码情况下,Rust的类型系统将禁止的数据结构.

- 理解未定义行为的定义将有助于你理解为什么它的后果远比仅仅获得不正确的结果更严重.

- Rust的外部函数接口允许你使用其他语言编写的库.

- 类似于`unsafe`函数的不安全traits强加了一个合同,每个实现(而不是每个调用者)必须遵循.

## 什么不安全?(Unsafe from What?)

在本书的开头,我们展示了一个以令人惊讶的方式崩溃的C程序,因为它没有遵循C标准规定的规则之一.你可以在Rust中执行相同的操作:

```Shell
$ cat crash.rs
fn main() {
    let mut a: usize = 0;
    let ptr = &mut a as *mut usize;
    unsafe {
        *ptr.offset(3) = 0x7ffff72f484c;
    }
}
$ cargo build
   Compiling unsafe-samples v0.1.0
    Finished debug [unoptimized + debuginfo] target(s) in 0.44 secs
$ ../../target/debug/crash
crash: Error: .netrc file is readable by others.
crash: Remove password or make file unreadable by others.
Segmentation fault (core dumped)
$
```

该程序借用对局部变量`a`的可变引用,将其转换为`*mut usize`类型的原始指针,然后使用`offset`方法在内存中产生一个指向三个字的指针.这恰好是存储`main`的返回地址的地方.程序用常量覆盖返回地址,以便从`main`返回以令人惊讶的方式运行.使这次崩溃成为可能的原因是程序错误地使用了不安全的功能--在这种情况下,能够解引用原始指针.

不安全的功能是强制签订 *合同(contract,或者说契约)* :Rust不能自动强制执行的规则.但你必须遵循这些规则以避免 *未定义行为(undefined behavior)* .

合同超出了通常的类型检查和生命周期检查,强加了针对该不安全功能的进一步规则.通常,Rust本身根本不知道合同;它只是在功能的文档中解释过.例如,原始指针类型有一个合约,禁止你解引用已超出其原始引用的对象结尾的指针.在这个例子中,表达式`*ptr.offset(3) = ...`打破了这个合约.但是,正如脚本所示,Rust在没有投诉的情况下编译程序:它的安全检查没有检测到这种违规行为.当你使用不安全的功能时,作为程序员,你有责任检查你的代码是否符合其合同.

很多功能都有你应该遵循的规则才能正确使用它们,但是这些规则不是我们所说的合同,除非可能的后果包括未定义行为.未定义行为是Rust坚定地假设你的代码永远不会展示的行为.例如,Rust假定你不会使用其他内容覆盖函数调用的返回地址.通过Rust通常的安全检查并遵守其使用的不安全功能的合同的代码不可能做到这一点.由于程序违反了原始指针契约,因此它的行为是未定义的,并且它会脱轨.

如果你的代码表现出未定义行为,那么你已经破坏了与Rust的交易的一半,Rust拒绝预测后果.从系统库的深处挖掘不相关的错误消息并导致崩溃是一个可能的后果;将控制权交给攻击者是另一回事.效果可能会有所不同,从Rust的一个版本到下一个版本,没有任何警告.但是,有时,未定义行为没有明显的后果.例如,如果`main`函数永远不会返回(可能它调用`std::process::exit`来提前终止程序),那么损坏的返回地址可能无关紧要.

你只能在`unsafe`块或`unsafe`函数中使用不安全的功能;我们将在后面的章节中解释.这使得在不知情的情况下更难使用不安全的功能:通过强制你编写`unsafe`块或函数,Rust确保你已确认你的代码可能有其他规则要遵循.

## 不安全块(Unsafe Blocks)

一个`unsafe`块看起来就像一个前面是`unsafe`关键字的普通的Rust块,,区别在于你可以在块中使用不安全的功能:

```Rust
unsafe {
    String::from_utf8_unchecked(ascii)
}
```

如果没有块前面的`unsafe`关键字,Rust会反对使用`from_utf8_unchecked`,这是一个`unsafe`函数.使用`unsafe`块包围它,你可以在任何地方使用此代码.

与普通的Rust块一样,`unsafe`的值是其最后一个表达的值,或者`()`如果块没有.前面显示的对`String::from_utf8_unchecked`的调用提供了块的值.

一个`unsafe`块为你解锁了四个额外的选项:

- 你可以调用`unsafe`函数.每个`unsafe`函数必须根据其目的指定自己的合约.

- 你可以解引用原始指针.安全代码可以传递原始指针,比较它们,并通过从引用(甚至从整数)转换来创建它们,但只有不安全的代码才能实际使用它们来访问内存.我们将详细介绍原始指针,并在第538页的"Raw Pointers(原始指针)"中解释如何安全地使用它们.

- 你可以访问可变的`static`变量.如第496页的"全局变量(Global Variables)"中所述,Rust无法确定线程何时使用可变的`static`变量,因此它们的合同要求你确保所有访问都已正确同步.

- 你可以访问通过Rust的外部函数接口声明的函数和变量.即使在不可变的情况下,这些也被认为是`unsafe`的,因为它们对于用其他语言编写的代码是可见的,这些代码可能不符合Rust的安全规则.

将不安全的功能限制为`unsafe`块并不能真正阻止你做任何你想做的事情.完全可以将`unsafe`块粘贴到代码中并继续前进.规则的好处主要在于引起人们对安全Rust无法保证的代码的关注:

- 你不会意外使用不安全的功能,然后发现你负责你甚至不知道存在的合同.

- `unsafe`块吸引了评论者的更多关注.有些项目甚至具有自动化功能来确保这一点,标记代码更改会影响`unsafe`块以获得特别关注.

- 当你考虑编写`unsafe`块时,你可以花点时间问自己,你的任务是否真的需要这些措施.如果是为了性能,你有测量结果表明这实际上是一个瓶颈吗?也许有一种很好的方法可以在安全的Rust中完成同样的事情.

### 示例:一个高效的ASCII字符串类型(Example: An Efficient ASCII String Type)

这是`Ascii`的定义,这是一种字符串类型,可确保其内容始终是有效的ASCII.此类型使用不安全的功能来提供零成本转换为`String`:

```Rust
mod my_ascii {
    use std::ascii::AsciiExt; // for u8::is_ascii

    /// An ASCII-encoded string.
    #[derive(Debug, Eq, PartialEq)]
    pub struct Ascii(
        // This must hold only well-formed ASCII text:
        // bytes from `0` to `0x7f`.
        Vec<u8>
    );

    impl Ascii {
        /// Create an `Ascii` from the ASCII text in `bytes`. Return a
        /// `NotAsciiError` error if `bytes` contains any non-ASCII
        /// characters.
        pub fn from_bytes(bytes: Vec<u8>) -> Result<Ascii, NotAsciiError> {
            if bytes.iter().any(|&byte| !byte.is_ascii()) {
                return Err(NotAsciiError(bytes))
            }
            Ok(Ascii(bytes))
        }
    }

    // When conversion fails, we give back the vector we couldn't convert.
    // This should implement `std::error::Error`; omitted for brevity.
    #[derive(Debug, Eq, PartialEq)]
    pub struct NotAsciiError(pub Vec<u8>);

    // Safe, efficient conversion, implemented using unsafe code.
    impl From<Ascii> for String {
        fn from(ascii: Ascii) -> String {
            // If this module has no bugs, this is safe, because
            // well-formed ASCII text is also well-formed UTF-8.
            unsafe { String::from_utf8_unchecked(ascii.0) }
        }
    }
    ...
}
```

该模块的关键是`Ascii`类型的定义.类型本身标记为`pub`,以使其在`my_ascii`模块外部可见.但是类型的`Vec<u8>`元素 *不是(not)* 公有的,因此只有`my_ascii`模块可以构造`Ascii`值或引用其元素.这使模块的代码完全控制可能出现或未出现的内容.只要公有构造函数和方法确保新创建的`Ascii`值的格式良好并且在其整个生命中保持如此,那么程序的其余部分就不会违反该规则.实际上,公有构造函数`Ascii::from_bytes`在同意从中构造`Ascii`之前仔细检查它给出的向量.为简洁起见,我们没有显示任何方法,但你可以设想一组文本处理方法,确保`Ascii`值始终包含正确的ASCII文本,就像`String`的方法确保其内容保持格式良好的UTF-8.

这种安排让我们非常高效地为`String`实现`From<Ascii>`.不安全的函数`String::from_utf8_unchecked`接受一个字节向量并从中构建一个`String`,而不检查它的内容是否是格式正确的UTF-8文本;函数的契约让其调用者对此负责.幸运的是,`Ascii`类型强制执行的规则正是我们需要满足`from_utf8_unchecked`的合同.正如我们在第392页的"UTF-8(UTF-8)"中所解释的那样,任何ASCII文本块也都是格式良好的UTF-8,因此`Ascii`的底层`Vec<u8>`可以立即用作`String`的缓冲区.

有了这些定义,你可以写:

```Rust
use my_ascii::Ascii;

let bytes: Vec<u8> = b"ASCII and ye shall receive".to_vec();

// This call entails no allocation or text copies, just a scan.
let ascii: Ascii = Ascii::from_bytes(bytes)
    .unwrap(); // We know these chosen bytes are ok.

// This call is zero-cost: no allocation, copies, or scans.
let string = String::from(ascii);
assert_eq!(string, "ASCII and ye shall receive");
```

使用`Ascii`不需要`unsafe`块.我们使用不安全的操作实现了一个安全的接口,并且只根据模块自己的代码而不是用户的行为安排来满足他们的合同.

`Ascii`只不过是`Vec<u8>`的包装器,隐藏在一个模块中,该模块强制执行有关其内容的额外规则.这种类型称为 *newtype* ,Rust中的常见模式.Rust自己的`String`类型以完全相同的方式定义,只是它的内容被限制为UTF-8,而不是ASCII.实际上,这是标准库中`String`的定义:

```Rust
pub struct String {
    vec: Vec<u8>,
}
```

在机器级别,在不显示Rust类型的情况下,newtype及其元素在内存中具有相同的表示,因此构造newtype根本不需要任何机器指令.在`Ascii::from_bytes`中,表达式`Ascii(bytes)`只是认为`Vec<u8>`的表示现在保持Ascii值.类似地,`String::from_utf8_unchecked`在内联时可能不需要机器指令:`Vec<u8>`现在被认为是一个`String`.

## 不安全函数(Unsafe Functions)

`unsafe`函数定义看起来像一个普通的函数定义,前面是`unsafe`关键字.`unsafe`函数的主体自动被视为`unsafe`块.

你可以仅在`unsafe`块中调用`unsafe`函数.这意味着标记函数`unsafe`会警告其调用者该函数具有必须满足的约定以避免未定义行为.

例如,这里是我们之前介绍的`Ascii`类型的新构造函数,它从字节向量构建`Ascii`,而不检查其内容是否是有效的ASCII:

```Rust
// This must be placed inside the `my_ascii` module.
impl Ascii {
    /// Construct an `Ascii` value from `bytes`, without checking
    /// whether `bytes` actually contains well-formed ASCII.
    ///
    /// This constructor is infallible, and returns an `Ascii` directly,
    /// rather than a `Result<Ascii, NotAsciiError>` as the `from_bytes`
    /// constructor does.
    ///
    /// # Safety
    ///
    /// The caller must ensure that `bytes` contains only ASCII
    /// characters: bytes no greater than 0x7f. Otherwise, the effect is
    /// undefined.
    pub unsafe fn from_bytes_unchecked(bytes: Vec<u8>) -> Ascii {
        Ascii(bytes)
    }
}
```

据推测,调用`Ascii::from_bytes_unchecked`的代码已经知道手中的向量只包含ASCII字符,因此`Ascii::from_bytes`坚持执行的检查将浪费时间,并且调用者必须编写代码来处理`Err`的结果,它知道永远不会发生.`Ascii::from_bytes_unchecked`允许这样的调用者回避检查和错误处理.

但是`Ascii`类型定义上面的注释说:"这个模块中的任何内容都不允许将非ASCII字节引入`Ascii`值."这不正是这个新的`from_bytes_unchecked`构造函数的作用吗?

不完全是:`from_bytes_unchecked`通过合同将它们传递给调用者来履行其义务.这个合同的存在使得标记这个函数`unsafe`是正确的:尽管函数本身不执行不安全的操作,但它的调用者必须遵守规则Rust不能自动强制执行以避免未定义行为.

你真的可以通过违反`Ascii::from_bytes_unchecked`的合同来导致未定义行为吗?是的.你可以构造一个包含格式错误的UTF-8的`String`,如下所示:

```Rust
// Imagine that this vector is the result of some complicated process
// that we expected to produce ASCII. Something went wrong!
let bytes = vec![0xf7, 0xbf, 0xbf, 0xbf];

let ascii = unsafe {
    // This unsafe function's contract is violated
    // when `bytes` holds non-ASCII bytes.
    Ascii::from_bytes_unchecked(bytes)
};

let bogus: String = ascii.into();

// `bogus` now holds ill-formed UTF-8. Parsing its first character
// produces a `char` that is not a valid Unicode code point.
assert_eq!(bogus.chars().next().unwrap() as u32, 0x1fffff);
```

这说明了有关bugs和不安全代码的两个关键事实:

- *在`unsafe`块之前发生的bugs可能会破坏合同(Bugs that occur before the `unsafe` block can break contracts)* .`unsafe`块是否导致未定义行为不仅取决于块本身的代码,还取决于提供其操作的值的代码.你的`unsafe`代码依赖于满足合同的一切都是安全至关重要的.仅当模块的其余部分正确维护`Ascii`的不变量时,才能很好地定义基于`String::from_utf8_unchecked`从`Ascii`到`String`的转换.

- *违约的后果可能会出现在离开`unsafe`块之后(the consequences of breaking a contract may appear after you leave the `unsafe` block)* .未遵守不安全功能合同所引起的未定义行为通常不会发生在`unsafe`块内.如前所示构造伪造的`String`可能不会导致问题,直到程序执行的后期.

从本质上讲,Rust的类型检查器,借用检查器和其他静态检查正在检查你的程序并尝试构建一个证明,证明它不能表现出未定义行为.当Rust成功编译你的程序时,这意味着它成功地证明了你的代码声音.一个`unsafe`块是这个证明中的一个空白:"这段代码,"你对Rust说,"很好,相信我."你的主张是否真实可能取决于程序的任何部分,它们影响`unsafe`块中发生的事情,并且出现错误的后果可能会出现在任何受`unsafe`块影响的地方.编写`unsafe`关键字相当于提醒你,你没有从语言的安全检查中获得全部好处.

鉴于选择,你自然应该更喜欢创建安全的接口,而无需合同.这些更容易使用,因为用户可以依靠Rust的安全检查来确保他们的代码没有未定义行为.即使你的实现使用不安全的功能,也最好使用Rust的类型,生命周期和模块系统来满足它们的合同,同时只使用你自己可以保证的内容,而不是将责任传递给你的调用者.

不幸的是,在野外遇到不安全函数并不罕见,其文档无需解释它们的合同.根据你的经验和代码行为的知识,你需要自己推断规则.如果你曾经不安地想知道你使用C或C++ API做的是否正常,那么你就知道它是什么样的.

## 不安全块还是不安全函数?(Unsafe Block or Unsafe Function?)

你可能会发现自己想知道是使用`unsafe`块还是只是标记整个函数不安全.我们建议的方法是先做出关于函数的决定:

- 如果以可编译的方式滥用函数但仍导致未定义行为,则必须将其标记为不安全.正确使用该函数的规则是其合同;合同的存在是使函数不安全的原因.

- 否则,该函数是安全的:没有对其进行良好类型的调用会导致未定义行为.它不应该被标记为`unsafe`.

函数是否在其主体中使用不安全的功能是无关紧要的;重要的是合同的存在.之前,我们展示了一个不安全函数,它不使用不安全的功能,以及一个使用不安全功能的安全函数.

不要因为在体使用不安全的功能而将安全函数标记为`unsafe`.这使得该函数更难以使用,并且会使(正确地)期望找到合同解释的读者感到困惑.相反,使用`unsafe`块,即使它是函数的整个主体.

## 未定义行为(Undefined Behavior)

在介绍中,我们说术语 *未定义行为(undefined behavior)* 意味着"Rust坚定地认为你的代码永远不会表现出来的行为(behavior that Rust firmly assumes your code could never exhibit)."这是一个奇怪的短语转变,特别是因为我们从其他语言的经验中知道这些行为 *确实(do)* 是偶然发生的,有一定频率.为什么这个概念有助于规定不安全代码的义务?

编译器是从一种编程语言到另一种编程语言的翻译器.Rust编译器接受Rust程序并将其转换为等效的机器语言程序.但是,说这种完全不同语言的两个程序是等价的是什么意思呢?

幸运的是,对于程序员而言,这个问题比语言学家更容易.我们通常说两个程序是等价的,如果它们在执行时总是具有相同的可见行为:它们进行相同的系统调用,以相同的方式与外部库交互,等等.这有点像程序的图灵测试:如果你不能分辨你是在与原始的还是翻译的进行交互,那么它们就是等价的.

现在考虑以下代码:

```Rust
let i = 10;
very_trustworthy(&i);
println!("{}", i * 100);
```

即使对于`very_trustworthy`的定义一无所知,我们也可以看到它只接收到对`i`的共享引用,因此调用不能改变`i`的值.由于传递给`println!`的值将始终为`1000`,Rust可以将此代码转换为机器语言,就像我们这样写的一样:

```Rust
very_trustworthy(&10);
println!("{}", 1000);
```

此转换版本具有与原始版本相同的可见行为,并且可能更快一些.但只有在我们同意它与原版具有相同含义的情况下考虑此版本的性能才是有意义的.如果`very_trustworthy`的定义如下?

```Rust
fn very_trustworthy(shared: &i32) {
    unsafe {
        // Turn the shared reference into a mutable pointer.
        // This is undefined behavior.
        let mutable = shared as *const i32 as *mut i32;
        *mutable = 20;
    }
}
```

此代码违反了共享引用的规则:它将`i`的值更改为`20`,即使它应该被冻结,因为`i`是共享借用.结果,我们对调用者的转换现在具有非常明显的效果:如果Rust转换代码,程序将打印`1000`;如果它单独留下代码并使用`i`的新值,则打印`2000`.在`very_trustworthy`中打破共享引用的规则意味着共享引用在其调用者中不会按预期运行.

这种问题出现在Rust可能尝试的几乎所有类型的转换中.甚至将函数内联到其调用点中也假设,当被调用者结束时,控制流返回到调用点.但是我们打开了这一章,其中包含了一个违反该假设的不良行为代码的例子.

Rust(或任何其他语言)基本上不可能评估程序的转换是否保留其含义,除非它可以信任该语言的基本功能以按设计行事.它们是否有所不同,不仅取决于手头的代码,还取决于其他(可能很遥远)的程序部分.为了对你的代码做任何事情,Rust必须假设你的程序的其余部分都表现良好.

这里是Rust的,对于表现良好的程序的规则:

- 程序不得读取未初始化的内存.

- 程序不得创建无效的原始值:
  - 引用或boxes为`bull`
  - `bool`值不是`0`或`1`
  - 具有无效判别值的`enum`值
  - 无效的`char`值,无代码的Unicode代码点
  - `str`值不是格式良好的UTF-8

- 必须遵守第5章中解释的引用规则.没有任何引用可以活得比它引用的对象更久;共享访问是只读访问;并且可变访问是独占访问.

- 程序不得解引用`null`,错误对齐或悬空指针.

- 程序不得使用指针访问与指针关联的分配之外的内存.我们将在第540页的"安全地解引用原始指针(Dereferencing Raw Pointers Safely)"中详细解释此规则.

- 程序必须没有数据竞争.当两个线程在没有同步的情况下访问相同的内存位置时,会发生数据竞争,并且至少有一个访问是写入.

- 程序不得通过外部函数接口,在另一种语言的调用中展开,如第146页的"展开(Unwinding)"中所述.

- 程序必须符合标准库函数的合同.

这些规则都是Rust在优化程序并将其转换为机器语言的过程中所假设的.简单来说,未定义行为违反了这些规则.这就是为什么我们说Rust假定你的程序不会出现未定义行为:如果我们希望得出结论编译的程序是源代码的忠实翻译,那么这个假设是必要的.

不使用不安全功能的Rust代码保证在编译后遵循所有前面的规则.一旦其编译.只有当你使用不安全的功能时,这些规则才会成为你的责任.在C和C++中,程序编译时没有错误或警告意味着更少;正如我们在本书的介绍中所提到的那样,即使是那些将代码保持在高标准的备受尊重的项目所编写的最好的C和C++程序在实践中也表现出不未定义行为.

## 不安全Traits(Unsafe Traits)

*不安全trait(unsafe trait)* 是具有合同的trait,Rust无法检查或强制实现者必须满足以避免未定义行为.要实现不安全trait,必须将实现标记为不安全.由你来理解trait的合同,并确保你的类型满足它.

用不安全trait限制其类型变量的函数通常是使用不安全的功能的函数,并且仅通过依赖于不安全trait的契约来满足其合同.trait的不正确实现可能导致此类函数表现出未定义行为.

不安全traits的典型例子是`std::marker::Send`和`std::marker::Sync`.这些traits没有定义任何方法,因此对于你喜欢的任何类型实现它们都很简单.但它们确实有合同:`Send`要求实现者安全地移动到另一个线程,`Sync`要求它们通过共享引用安全地在线程之间共享.例如,为不合适的类型实现`Send`会使`std::sync::Mutex`不再对数据竞争安全.

举一个简单的例子,Rust库包含一个不安全的特性`core::nonzero::Zeroable`,用于可以通过将所有字节设置为0来安全地初始化的类型,很明显,将`usize`归零很好,但将`&T`归零会给你一个空引用,如果解引用会导致崩溃.对于可归零(zeroable)的类型,可以进行一些优化:你可以使用`std::mem::write_bytes`(Rust的`memset`等价物)快速初始化它们的数组,或者使用分配归零页面的操作系统调用.(从Rust 1.17开始,`Zeroable`是实验性的,所以它可能会在Rust的未来版本中被更改或删除,但它是一个好的,简单的,真实的例子.)

`Zeroable`是典型的标记trait,缺少方法或关联类型:

```Rust
pub unsafe trait Zeroable {}
```

适当类型的实现同样简单明了:

```Rust
unsafe impl Zeroable for u8 {}
unsafe impl Zeroable fori32 {} 
unsafe impl Zeroable for usize {}
// and so on for all the integer types
```

有了这些定义,我们可以编写一个函数,快速分配包含`Zeroable`类型的给定长度的向量:

```Rust
#![feature(nonzero)]
// permits `Zeroable`
extern crate core;
use core::nonzero::Zeroable;

fn zeroed_vector<T>(len: usize) -> Vec<T>
    where T: Zeroable
{
    let mut vec = Vec::with_capacity(len);
    unsafe {
        std::ptr::write_bytes(vec.as_mut_ptr(), 0, len);
        vec.set_len(len);
    }
    vec
}
```

此函数首先创建一个具有所需容量的空`Vec`,然后调用`write_bytes`以用零填充未占用的缓冲区.(`write_byte`函数将`len`视为`T`元素的个数,而不是字节的个数,因此该调用会填充整个缓冲区.)向量的`set_len`方法更改其长度而不对缓冲区执行任何操作;这是不安全的,因为你必须确保新封闭的缓冲区空间实际上包含类型为`T`的正确初始化值.但这正是`T: Zeroable`限制所建立的:零字节块表示有效的`T`值.我们使用`set_len`是安全的.

在这里,我们使用它:

```Rust
let v: Vec<usize> = zeroed_vector(100_000);
assert!(v.iter().all(|&u| u == 0));
```

显然,`Zeroable`必须是不安全trait,因为不遵守其合同的实现可能导致未定义行为:

```Rust
struct HoldsRef<'a>(&'a mut i32);

unsafe impl<'a> Zeroable for HoldsRef<'a> { }

let mut v: Vec<HoldsRef> = zeroed_vector(1);
*v[0].0 = 1;   // crashes: dereferences null pointer
```

Rust在没有抱怨的情况下编译它:它不知道`Zeroable`意味着什么,所以它无法判断它何时被用于不适当的类型.与任何其他不安全功能一样,由你来理解并遵守不安全trait的合同.

请注意,不安全的代码不能依赖于正确实现的普通,安全特性.例如,假设有一个`std::hash::Hasher`trait的实现,它只返回一个随机哈希值,与被哈希的值无关.该trait要求对两次相同的位进行哈希必须产生相同的哈希值,但此实现不符合该要求;这完全是错误的.但是因为`Hasher`不是一个不安全trait,所以当使用这个hasher时,不安全代码不得表现出未定义行为.`std::collections::HashMap`类型是经过精心编写的,以尊重它使用的不安全功能的合同,无论hasher的行为如何.当然,该表将无法正常运行:查找将失败,并且条目将随机出现和消失.但该表不会显示未定义行为.

## 原始指针(Raw Pointers)

Rust中的 *原始指针(raw pointer)* 是一个不受约束的指针.你可以使用原始指针来形成Rust的检查指针类型不能的各种结构,例如双向链表或对象的任意图形.但由于原始指针非常灵活,Rust无法判断你是否安全使用它们,因此你只能在`unsafe`块中解引用它们.

原始指针本质上等同于C或C++指针,因此它们对于与用这些语言编写的代码进行交互也很有用.有两种原始指针:

- `*mut T`是指向`T`的原始指针,允许修改其引用的对象.

- `*const T`是指向T的原始指针,只允许读取其引用的对象.

(没有普通的`*T`类型;你必须始终指定`const`或`mut`.)

你可以通过从引用转换来创建原始指针,并使用`*`运算符解引用它:

```Rust
let mut x = 10;
let ptr_x = &mut x as *mut i32;

let y = Box::new(20);
let ptr_y = &*y as *const i32;

unsafe {
    *ptr_x += *ptr_y;
}
assert_eq!(x, 30);
```

与boxes和引用不同,原始指针可以为空(null),如C中的`NULL`或C++中的`nullptr`:

```Rust
fn option_to_raw<T>(opt: Option<&T>) -> *const T {
    match opt {
        None => std::ptr::null(),
        Some(r) => r as *const T
    }
}

assert!(!option_to_raw(Some(&("pea", "pod"))).is_null());
assert_eq!(option_to_raw::<i32>(None), std::ptr::null());
```

这个例子没有`unsafe`块:创建原始指针,传递它们,并比较它们都是安全的.只有解引用原始指针是不安全的.

指向无大小的(unsized)类型的原始指针是胖指针,就像相应的引用或`Box`类型一样.一个`*const [u8]`指针包含一个长度和地址,一个trait对象如`*mut std::io::Write`指针携带一个虚表(vtable).

虽然Rust在各种情况下隐式地解引用安全指针类型,但原始指针解引用必须是显式的:

- `.`运算符不会隐式解引用原始指针;你必须写`(*raw).field`或`(*raw).method(...)`.

- 原始指针不实现`Deref`,因此解引用强制(deref coercions)不适用于它们.

- 运算符如`==`和`<`将原始指针作为地址进行比较:如果两个原始指针指向内存中的相同位置,则它们是相等的.类似地,哈希原始指针会哈希它指向的地址,而不是其引用的对象的值.

- 格式化traits如`std::fmt::Display`会自动跟踪引用,但根本不处理原始指针.例外是`std::fmt::Debug`和`std::fmt::Pointer`,它们将原始指针显示为十六进制地址,而不解引用它们.

与C和C++中的`+`运算符不同,Rust的`+`不处理原始指针,但你可以通过其`offset`和`wrapping_offset`方法执行指针运算.找到两个指针之间的距离没有标准操作,就像`-`运算符在C和C++中那样,但你可以自己编写一个:

```Rust
fn distance<T>(left: *const T, right: *const T) -> isize {
    (left as isize - right as isize) / std::mem::size_of::<T>() as isize
}

let trucks = vec!["garbage truck", "dump truck", "moonstruck"];
let first = &trucks[0];
let last = &trucks[2];
assert_eq!(distance(last, first), 2);
assert_eq!(distance(first, last), -2);
```

即使`distance`的参数是原始指针,我们也可以将引用传递给它:Rust隐含地强制引用原始指针(当然不是反过来).

`as`运算符允许从引用到原始指针或两个原始指针类型之间的几乎所有合理的转换.但是,你可能需要将复杂的转换分解为一系列简单的步骤.例如:

```Rust
&vec![42_u8] as *const String// error: invalid conversion
&vec![42_u8] as *const Vec<u8> as *const String;  // permitted
```

请注意,`as`不会将原始指针转换为引用.这样的转换将是不安全的,`as`应该保持安全操作.相反,你必须解引用原始指针(在`unsafe`块中),然后借用结果值.

执行此操作时要非常小心:以这种方式生成的引用具有不受约束的生命周期:它可以存活多长时间没有限制,因为原始指针使得Rust无法做出这样的决定.在本章后面的第572页的"libgit2的安全接口(A Safe Interface to libgit2)"中,我们将展示如何正确约束生命周期的几个示例.

许多类型都有`as_ptr`和`as_mut_ptr`方法,它们返回指向其内容的原始指针.例如,数组切片和字符串返回指向其第一个元素的指针,一些迭代器返回指向它们将生成的下一个元素的指针.像`Box`,`Rc`和`Arc`这样的拥有指针类型有`into_raw`和`from_raw`函数,可以转换为原始指针和从原始指针转换来.其中一些方法的合同带来了令人惊讶的要求,因此在使用它们之前请查阅它们的文档.

你也可以通过从整数转换来构造原始指针,尽管你可以信任的唯一整数通常是你首先从指针获得的整数.第541页的"示例:RefWithFlag(Example: RefWithFlag)"以这种方式使用原始指针.

与引用不同,原始指针既不是`Send`也不是`Sync`.因此,默认情况下,包含原始指针的任何类型都不会实现这些traits.在线程之间发送或共享原始指针没有什么本质上不安全的;毕竟,无论它们走到哪里,你仍然需要一个`unsafe`块来解引用它们.但是考虑到原始指针通常扮演的角色,语言设计者认为这种行为是更有用的默认行为.我们已经在第536页的"不安全Traits(Unsafe Traits)"中讨论了如何自己实现`Send`和`Sync`.

### 安全地解引用原始指针(Dereferencing Raw Pointers Safely)

以下是一些安全使用原始指针的常识性指南:

- 解引用空指针或悬空指针是未定义行为,因为指向未初始化的内存或超出作用域的值.

- 解引用未针对其引用的对象类型正确对齐的指针是未定义行为.

- 只有在遵守第5章中解释的引用安全规则的情况下,你才可以从解引用的原始指针借用值:没有引用可能比它的引用的对象活得更久;共享访问是只读访问;可变访问是独占访问.(此规则很容易被违反,因为原始指针通常用于创建具有非标准共享或所有权的数据结构.)

- 只有当它是格式良好的其类型的值时,才可以使用原始指针的引用的对象.例如,你必须确保解引用`*const char`会产生正确的,非代理(nonsurrogate)的Unicode代码点.

- 你可以在原始指针上使用`offset`和`wrapping_offset`方法,仅指向原始指针所引用的变量或堆分配的内存块中的字节,或指向此区域之外的第一个字节.

如果通过将指针转换为整数来进行指针运算,对整数进行算术运算,然后将其转换回指针,则结果必须是`offset`方法的规则允许你生成的指针.

- 如果赋值给原始指针的引用对象,则不得违反引用对象所属的任何类型的不变量.例如,如果你有一个`*mut u8`指向一个`String`的一个字节,你可能只存储`u8`中的值,使得`String`保持格式良好的UTF-8.

除了借用规则,这些规则与在C或C++中使用指针时必须遵循的规则基本相同.

不违反类型不变量的原因应该是清楚的.Rust的许多标准类型在其实现中使用不安全代码,但仍然提供安全的接口,假设Rust的安全检查,模块系统和可见性规则将得到尊重.使用原始指针来规避这些保护措施可能导致未定义行为.

原始指针的完整,准确的合约不容易说明,并且可能随着语言的发展而变化.但是这里列出的原则应该让你处于安全的境地.

### 示例:RefWithFlag(Example: RefWithFlag)

下面是一个示例,说明如何通过原始指针实现经典的位级别的hack,并将其包装为完全安全的Rust类型.这个模块定义了一个类型,`RefWithFlag<'a, T>`,它同时包含一个`&'a T`和一个`bool`,就像元组`(&'a T, bool),但仍然设法只占用一个机器字而不是两个.这种技术经常用于垃圾收集器和虚拟机,其中某些类型--如表示对象的类型--如此之多,以至于每个值添加单个字会大大增加内存使用量:

```Rust
mod ref_with_flag {
    use std::marker::PhantomData;
    use std::mem::align_of;

    /// A `&T` and a `bool`, wrapped up in a single word.
    /// The type `T` must require at least two-byte alignment.
    ///
    /// If you're the kind of programmer who's never met a pointer whose
    /// 2⁰-bit you didn't want to steal, well, now you can do it safely!
    /// ("But it's not nearly as exciting this way...")
    pub struct RefWithFlag<'a, T: 'a> {
        ptr_and_bit: usize,
        behaves_like: PhantomData<&'a T> // occupies no space
    }

    impl<'a, T: 'a> RefWithFlag<'a, T> {
        pub fn new(ptr: &'a T, flag: bool) -> RefWithFlag<T> {
            assert!(align_of::<T>() % 2 == 0);
            RefWithFlag {ptr_and_bit: ptr as *const T asusize | flag as usize,
            behaves_like: PhantomData
        }
    }

    pub fn get_ref(&self) -> &'a T {
        unsafe {
            let ptr = (self.ptr_and_bit & !1) as *const T;
            &*ptr
        }
    }

    pub fn get_flag(&self) -> bool {
        self.ptr_and_bit & 1 != 0
        }
    }
}
```

这段代码利用了许多类型必须放在内存中偶数地址的事实:因为偶数地址的最低有效位总是为零,我们可以在那里存储其他东西,然后通过屏蔽底位可靠地重建原始地址位.并非所有类型都符合条件;例如,类型`u8`和`(bool, [i8; 2])`可以放在任何地址.但是我们可以在构造时检查类型的对齐情况,拒绝不起作用的类型.

你可以像这样使用`RefWithFlag`:

```Rust
use ref_with_flag::RefWithFlag;

let vec = vec![10, 20, 30];
let flagged = RefWithFlag::new(&vec, true);
assert_eq!(flagged.get_ref()[1], 20);
assert_eq!(flagged.get_flag(), true);
```

构造函数`RefWithFlag::new`接受引用和`bool`值,断言引用的类型是合适的,然后将引用转换为原始指针,然后转换为`usize`.`usize`类型被定义为足够大以在我们正在编译的任何处理器上保存指针,因此将原始指针转换为`usize`和转回是良好定义的.一旦我们有了一个`usize`,我们知道它必须是偶数,所以我们可以使用`|`按位或运算符将它与`bool`组合,我们已将其转换为整数`0`或`1`.

`get_flag`方法提取`RefWithFlag`的`bool`组件.这很简单:只需掩盖底位并检查它是否非零.

`get_ref`方法从`RefWithFlag`中提取引用.首先,它掩盖了`usize`的底位并将其转换为原始指针.`as`运算符不会将原始指针转换为引用,但是我们可以解引用原始指针(当然是在一个`unsafe`块中)并借用它.借用一个原始指针的引用对象为你提供一个无限生命周期的引用:Rust会给出引用,无论生命周期会使它周围的代码检查,如果有的话.但是,通常情况下,某些特定的生命周期更准确,因此会出现更多错误.在这种情况下,由于`get_ref`的返回类型是`&'a T`,Rust推断引用的生命周期必须是`RefWithFlag`的参数,这正是我们想要的:这是我们开始的引用的生命周期.

在内存中,`RefWithFlag`看起来就像一个`usize`:由于`PhantomData`是一个零大小的类型,所以`behaves_like`字段在结构中不占用空间.但是,`PhantomData`是Rust知道如何在使用`RefWithFlag`的代码中处理生命周期的必要条件.想象一下没有`behaves_like`字段时类型会是什么样子:

```Rust
// This won't compile.
pub struct RefWithFlag<'a, T: 'a> {
    ptr_and_bit: usize
}
```

在第5章中,我们指出任何包含引用的结构都不得活得比它们借用的值更久,以免引用成为悬空指针.结构必须遵守适用于其字段的限制.这当然适用于`RefWithFlag`:在我们刚看到的示例代码中,`flagged`不得活得比`vec`久,因为`flagged.get_ref()`返回对它的引用.但是我们减少的`RefWithFlag`类型根本不包含任何引用,并且从不使用它的生命周期参数`'a`.它只是一个`usize`.Rust怎么知道任何限制都适用于`pab`的生命周期?包括一个`PhantomData<&'a T>`字段告诉Rust将`RefWithFlag<'a, T>`*视为就好像(as if)* 它包含`&'a T`,而不实际影响结构的表示.

虽然Rust并不真正知道发生了什么(这就是让`RefWithFlag`不安全的原因),但它会尽力帮助你解决这个问题.如果省略`_marker`字段,Rust会抱怨参数`'a`和`T`未使用,并建议使用`PhantomData`.

`RefWithFlag`使用与我们之前介绍的`Ascii`类型相同的策略,以避免其`unsafe`块中的未定义行为.类型本身是`pub`,但它的字段不是，,意味着只有`pointer_and_bool`模块中的代码可以创建或查看`RefWithFlag`值.你不必检查太多代码就可以确信`ptr_and_bit`字段构造良好.

### 可空的指针(Nullable Pointers)

Rust中的空(null)原始指针是一个零地址,就像在C和C++中一样.对于任何类型`T`,`std::ptr::null<T>`函数返回`*const T`空指针,`std::ptr::null_mut<T>`返回`*mut T`空指针.

有几种方法可以检查原始指针是否为空.最简单的是`is_null`方法,但是`as_ref`方法可能更方便:它接受`*const T`指针并返回`Option<&'a T>`,将空指针转换为`None`.类似地,`as_mut`方法将`*mut T`指针转换为`Option<&'a mut T>`值.

### 类型大小和对齐(Type Sizes and Alignments)

任何`Sized`类型的值在内存中占用恒定的字节数,并且必须放置在由机器体系结构确定的某个 *对齐(alignment)* 值的倍数的地址处.例如,`(i32, i32)`元组占用8个字节,并且大多数处理器更喜欢将其放置在4的倍数的地址处.

调用`std::mem::size_of::<T>()`返回类型为`T`的值的大小(以字节为单位),`std::mem::align_of::<T>()`返回其所需的对齐.例如:

```Rust
assert_eq!(std::mem::size_of::<i64>(), 8);
assert_eq!(std::mem::align_of::<(i32, i32)>(), 4);
```

任何类型的对齐总是2的幂.

类型的大小总是向上舍入到其对齐的倍数,即使它在技术上可以适合更小的空间.例如,即使像`(f32, u8)`这样的元组只需要五个字节,`size_of::<(f32, u8)>()`也是`8`,因为`align_of::<(f32, u8)>()`是`4`.这可确保如果你有数组,则元素类型的大小始终反映一个元素与下一个元素之间的间距.

对于无大小的类型,大小和对齐取决于手头的值.给定对无大小的值的引用,`std::mem::size_of_val`和`std::mem::align_of_val`函数返回值的大小和对齐.这些函数可以对`Sized`和无大小类型的引用进行操作.

```Rust
// Fat pointers to slices carry their referent's length.
let slice: &[i32] = &[1, 3, 9, 27, 81];
assert_eq!(std::mem::size_of_val(slice), 20);

let text: &str = "alligator";
assert_eq!(std::mem::size_of_val(text), 9);

use std::fmt::Display;
let unremarkable: &Display = &193_u8;
let remarkable: &Display = &0.0072973525664;

// These return the size/alignment of the value the
// trait object points to, not those of the trait object
// itself. This information comes from the vtable the
// trait object refers to.
assert_eq!(std::mem::size_of_val(unremarkable), 1);
assert_eq!(std::mem::align_of_val(remarkable), 8);
```

### 指针运算(Pointer Arithmetic)

Rust将数组,切片或向量的元素作为单个连续的内存块进行布局,如图21-1所示.元素是规则间隔的,因此如果每个元素占用`size`字节,则第`i`个元素以第`i * size`字节开始.

*图21-1. 内存种的数组.*

这样做的一个好结果是,如果你有两个指向数组元素的原始指针,比较指针会得到与比较元素索引相同的结果:如果`i < j`,则指向第`i`个元素的原始指针小于指向第`j`个元素的原始指针.这使得原始指针可用作数组遍历的边界.实际上，标准库在切片上的简单迭代器定义如下:

```Rust
struct Iter<'a, T: 'a> {
    ptr: *const T,
    end: *const T,
    ...
}
```

`ptr`字段指向迭代应该产生的下一个元素,并且`end`字段用作限制:当`ptr == end`时,迭代完成.

数组布局的另一个好结果:如果`element_ptr`是一个`*const T`或`*mut T`原始指针,它指向某个数组的第`i`个元素,那么`element_ptr.offset(o)`是一个指向第`(i + o)`个元素的原始指针.它的定义等同于:

```Rust
fn offset(self: *const T, count: isize) -> *const T
    where T: Sized
{
    let bytes_per_element = std::mem::size_of::<T>() as isize;
    let byte_offset = count * bytes_per_element;
    (self as isize).checked_add(byte_offset).unwrap() as *const T
}
```

`std::mem::size_of::<T>`函数以字节为单位返回类型`T`的大小.根据定义,`isize`足够大以容纳地址,你可以将基指针转换为`isize`,对该值进行算术运算,然后将结果转换回指针.

在数组结束后生成指向第一个字节的指针是很好的.你不能解引用这样的指针,但它可以用于表示循环的限制或用于边界检查.

但是,使用`offset`来生成超出该点的,或者在数组开始之前的指针,即使你从未解引用它,也是未定义的行为.为了优化,Rust想假设当`i`是正数时,`ptr.offset(i) > ptr`,而当`i`是负数时,`ptr.offset(i) < ptr`.这个假设似乎是安全的,但如果`offset`中的算术溢出`isize`值,它可能不成立.如果`i`被约束为与`ptr`保持在同一个数组中,则不会发生溢出:毕竟,数组本身不会溢出地址空间的边界.(要使指向结束之后的第一个字节安全,Rust永远不会将值放在地址空间的上端.)

如果确实需要将指针偏移超出与它们关联的数组的限制,则可以使用`wrapping_offset`方法.这相当于`offset`,但Rust没有假设`ptr.wrapping_offset(i)`和`ptr`本身的相对排序.当然,除非它们属于数组,否则你仍然无法解引用这些指针.

### 移入和移出内存(Moving into and out of Memory)

如果要实现管理自己内存的类型,则需要跟踪内存的哪些部分保存活着的值,哪些部分未初始化,就像Rust处理局部变量一样.考虑以下代码:

```Rust
let pot = "pasta".to_string();
let plate;

plate = pot;
```

运行此代码后,情况如图21-2所示.

*图21-2. 将字符串从一个局部变量移动到另一个局部变量.*

赋值后,`pot`是未初始化的,`plate`是字符串的所有者.

在机器级别,没有指定移动对源的作用,但在实践中,它通常什么都不做.该赋值可能使`pot`仍然保持字符串的指针,容量和长度.当然.将此视为活着的值将是灾难性的,Rust确保你不这样做.

同样的考虑适用于管理自己内存的数据结构.假设你运行此代码:

```Rust
let mut noodles = vec!["udon".to_string()];
let soba = "soba".to_string();
let last;
```

在内存中,状态如图21-3所示.

*图21-3. 一个具有未初始化的,备用容量的向量.*

向量具有容纳一个元素的备用容量,但其内容是垃圾,可能是先前存储的内存.假设你然后运行此代码:

```Rust
noodles.push(soba);
```

将字符串压入向量会将未初始化的内存转换为新元素,如图21-4所示:

*图21-4. 将soba的值推入向量上之后.*

向量已初始化其空白空间以拥有该字符串,并增加其长度以将其标记为新的,活着的元素.向量现在是字符串的所有者;你可以引用它的第二个元素,并且删除向量将释放两个字符串.`soba`现在是未初始化的.

最后,考虑一下当我们从向量中弹出一个值时会发生什么:

```Rust
last = noodles.pop().unwrap();
```
