# 迭代器(Iterators)

> 这是漫长的一天结束.
> --Phil

原文

> It was the end of a very long day.
> --Phil

*迭代器(iterator)* 是一个生成一系列值的值,通常用于循环操作.Rust的标准库提供遍历向量,字符串,哈希表和其他集合的迭代器,还提供从输入流生成文本行的迭代器,到达网络服务器的连接的迭代器,通过通信通道从其他线程接收的值的迭代器,等等.当然,你可以为自己的目的实现迭代器.Rust的`for`循环提供了使用迭代器的自然的语法,但迭代器本身也提供了一组丰富的用于映射(mapping),过滤(filtering),连接(joining),收集(collecting)等的方法集.

Rust的迭代器具有灵活性,表现力和高效性.考虑以下函数,它返回前`n`个正整数的总和(通常称为 *第n个三角数(nth triangle number)* ):

```Rust
fn triangle(n: i32) -> i32 {
    let mut sum = 0;
    for i in 1..n+1 {
        sum += i;
    }
    sum
}
```

表达式`1..n+1`是`Range<i32>`值.`Range<i32>`是一个迭代器,它生成从其起始值(包括)到其结束值(不包括)的整数,因此你可以将它用作`for`循环的操作数,以将值从`1`加到`n`.

但是迭代器也有一个`fold`方法,你可以在等效定义中使用它:

```Rust
fn triangle(n: i32) -> i32 {
    (1..n+1).fold(0, |sum, item| sum + item)
}
```

从`0`开始作为运行总和,`fold`获取`1..n+1`产生的每个值并应用闭包`|sum, item| sum + item`去运行总和和值.闭包的返回值被视为新的运行总和.它返回的最后一个值是`fold`本身返回的值--在这种情况下,是整个序列的总和.如果你习惯于`for`和`while`循环,这可能看起来很奇怪,但是一旦你习惯了它,`fold`是一个清晰易懂的替代方案.

这是函数式编程语言的标准功能,它非常注重表现力.但Rust的迭代器经过精心设计,以确保编译器能够将它们转换为出色的机器码.在之前显示的第二个定义的发布版本中,Rust知道`fold`的定义,并将其内联为`triangle`.接下来,闭包`|sum, item| sum + item`被内联到那里.最后,Rust检查组合代码并认识到有一种更简单的方法可以计算数字从1到`n`的总和:总和总是等于`n * (n+1) / 2`.Rust将整个`triangle`体,循环,闭包以及所有内容转换为单个乘法指令和一些其他位运算.

这个例子恰好涉及简单的算术,但迭代器在更重要的使用时也表现良好.它们是Rust提供灵活的抽象的另一个例子,在典型使用中几乎不会产生任何开销.

本章的其余部分分为五个部分:

- 首先我们将解释`Iterator`和`IntoIterator`traits,它们是Rust迭代器的基础.

- 然后我们将介绍典型迭代器管道的三个阶段:从某种值源创建迭代器;通过选择或处理值来调整一种迭代器到另一种迭代器;然后消费迭代器产生的值.

- 最后,我们将展示如何为你自己的类型实现迭代器.

有很多方法,所以一旦你有了大概的想法就可以浏览一个部分.但迭代器在惯用Rust中很常见,熟悉它们附带的工具对掌握语言至关重要.

## Iterator和IntoIterator Traits(Iterator and IntoIterator Traits)

迭代器是实现`std::iter::Iterator`trait的任何值:

```Rust
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
    ... // many default methods
}
```

`Item`是迭代器生成的值的类型.`next`方法要么返回`Some(v)`,其中`v`是迭代器的下一个值,要么返回`None`以指示序列的结束.这里我们省略了`Iterator`的许多默认方法;在本章的其余部分我们将单独介绍它们.

如果有一种自然的迭代某种类型的方式,它可以实现`std::iter::IntoIterator`,其`into_iter`方法接受一个值并在其上返回一个迭代器:

```Rust
trait IntoIterator where Self::IntoIter::Item == Self::Item {
    type Item;
    type IntoIter: Iterator;
    fn into_iter(self) -> Self::IntoIter;
}
```

`IntoIter`是迭代器值本身的类型,`Item`是它生成的值的类型.我们将实现`IntoIterator`的任何类型称为 *可迭代的(iterable)* ,因为如果你问的话,你可以迭代它.

Rust的`for`循环将所有这些部分很好地结合在一起.要迭代向量的元素,你可以编写:

```Rust
println!("There's:");
let v = vec!["antimony", "arsenic", "aluminum", "selenium"];

for element in &v {
    println!("{}", element);
}
```

在底层,每个`for`循环只是对`IntoIterator`和`Iterator`方法的调用的简写:

```Rust
let mut iterator = (&v).into_iter();
while let Some(element) = iterator.next() {
    println!("{}", element);
}
```

`for`循环使用`IntoIterator::into_iter`将其操作数`&v`转换为迭代器,然后重复调用`Iterator::next`.每次返回`Some(element)`时,`for`循环执行它的主体;如果它返回`None`,则循环结束.

虽然`for`循环总是在其操作数上调用`into_iter`,但你也可以直接将迭代器传递给`for`循环;例如,当你在`Range`上循环时会发生这种情况.所有迭代器都自动实现`IntoIterator`,使用一个简单地返回迭代器的`into_iter`方法.

如果在返回`None`之后再次调用迭代器的`next`方法,则`Iterator`trait不会指定它应该做什么.大多数迭代器只会再次返回`None`,但不是全部.(如果这样会导致问题,请参阅第338页的"保险(fuse)"中的`fuse`适配器.)

这是迭代器的一些术语:

- 正如我们所说, *迭代器(iterator)* 是实现`Iterator`的任何类型.

- *可迭代的(iterable)* 是实现`IntoIterator`的任何类型:你可以通过调用其`into_iter`方法获取迭代器.在这种情况下,向量引用`&v`是可迭代的.

- 迭代器 *生成(produces)* 值.

- 迭代器生成的值是 *项(items)* .这里的项是`"antimony"`,`"arsenic"`等.

- 接收迭代器生成的项的代码是 *消费者(consumer)* .在此示例中,`for`循环消费迭代器的项.

## 创建迭代器(Creating Iterators)

Rust标准库文档详细解释了每种类型提供的迭代器类型,但该库遵循一些通用约定来帮助你获得定向并找到所需内容.

## iter和iter_mut方法(iter and iter_mut Methods)

大多数集合类型提供`iter`和`iter_mut`方法,这些方法返回类型上的自然迭代器,从而生成每个项的共享或可变引用.像`&[T]`和`&str`这样的切片也有`iter`和`iter_mut`方法.如果你不打算让`for`循环为你处理它的话,这些方法是获取迭代器的最常用方法:

```Rust
let v = vec![4, 20, 12, 8, 6];
let mut iterator = v.iter();
assert_eq!(iterator.next(), Some(&4));
assert_eq!(iterator.next(), Some(&20));
assert_eq!(iterator.next(), Some(&12));
assert_eq!(iterator.next(), Some(&8));
assert_eq!(iterator.next(), Some(&6));
assert_eq!(iterator.next(), None);
```

这个迭代器的项类型是`&i32`:每次调用`next`都会产生对下一个元素的引用.直到我们到达向量的末尾.

每种类型都可以自由地实现`iter`和`iter_mut`,以任何最有意义的方式实现它的目的.`std::path::Path`上的`iter`方法返回一个迭代器,它一次产生一个路径组件:

```Rust
use std::ffi::OsStr;
use std::path::Path;

let path = Path::new("C:/Users/JimB/Downloads/Fedora.iso");
let mut iterator = path.iter();
assert_eq!(iterator.next(), Some(OsStr::new("C:")));
assert_eq!(iterator.next(), Some(OsStr::new("Users")));
assert_eq!(iterator.next(), Some(OsStr::new("JimB")));
...
```

此迭代器的项类型是`&std::ffi::OsStr`,它是操作系统调用接受的类型字符串的切片的借用.

### IntoIterator实现(IntoIterator Implementations)

当一个类型实现了`IntoIterator`时,你可以自己调用它的`into_iter`方法,就像`for`循环一样:

```Rust
// You should usually use HashSet, but its iteration order is
// nondeterministic, so BTreeSet works better in examples.
use std::collections::BTreeSet;
let mut favorites = BTreeSet::new();
favorites.insert("Lucy in the Sky With Diamonds".to_string());
favorites.insert("Liebesträume No. 3".to_string());

let mut it = favorites.into_iter();
assert_eq!(it.next(), Some("Liebesträume No. 3".to_string()));
assert_eq!(it.next(), Some("Lucy in the Sky With Diamonds".to_string()));
assert_eq!(it.next(), None);
```

大多数集合实际上提供了几个`IntoIterator`实现,用于共享引用,可变引用和移动:

- 给定对集合的 *共享引用(shared reference)* ,`into_iter`返回一个迭代器,该迭代器生成对其项的共享引用.例如,在前面的代码中,`(&favorites).into_iter()`将返回一个其`Item`类型为`&String`的迭代器.

- 给定对集合的 *可变引用(mutable reference)* ,`into_iter`返回一个迭代器,该迭代器生成对项的可变引用.例如,如果`vector`是某个`Vec<String>`,则调用`(&mut vector).into_iter()`将返回一个其`Item`类型为`&mut String`的迭代器.

- 当 *通过值(by value)* 传递集合时,`into_iter`返回一个迭代器,该迭代器获取集合的所有权并通过值返回项;项的所有权从集合移动到消费者,并且在此过程中消耗原始集合.例如,前面代码中的调用`favorites.into_iter()`返回一个迭代器,它通过值生成每个字符串;消费者接收每个字符串的所有权.当删除迭代器时,`BTreeSet`中剩余的任何元素也会被删除,并且该集的现在为空的外壳被丢弃.

由于`for`循环将`IntoIterator::into_iter`应用于其操作数,因此这三个实现创建了以下习惯用于迭代对集合的共享引用或可变引用,或者使用集合并获取其元素的所有权:

```Rust
for element in &collection { ... }
for element in &mut collection { ... }
for element in collection { ... }
```
