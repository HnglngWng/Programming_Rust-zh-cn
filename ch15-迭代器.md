# 迭代器(Iterators)

> 这是漫长一天的结束.
> --Phil

原文

> It was the end of a very long day.
> --Phil

*迭代器(iterator)* 是一个生成一系列值的值,通常用于循环操作.Rust的标准库提供遍历向量,字符串,哈希表和其他集合的迭代器,还提供从输入流生成文本行的迭代器,到达网络服务器的连接的迭代器,通过通信通道从其他线程接收的值的迭代器,等等.当然,你可以为自己的目的实现迭代器.Rust的`for`循环提供了使用迭代器的自然的语法,但迭代器本身也提供了一组丰富的用于映射(mapping),过滤(filtering),连接(joining),收集(collecting)等的方法集.

Rust的迭代器具有灵活性,表现力和高效性.考虑以下函数,它返回前`n`个正整数的总和(通常称为 *第n个三角数(nth triangle number)* ):

```Rust
fn triangle(n: i32) -> i32 {
    let mut sum = 0;
    for i in 1..n+1 {
        sum += i;
    }
    sum
}
```

表达式`1..n+1`是`Range<i32>`值.`Range<i32>`是一个迭代器,它生成从其起始值(包括)到其结束值(不包括)的整数,因此你可以将它用作`for`循环的操作数,以将值从`1`加到`n`.

但是迭代器也有一个`fold`方法,你可以在等效定义中使用它:

```Rust
fn triangle(n: i32) -> i32 {
    (1..n+1).fold(0, |sum, item| sum + item)
}
```

从`0`开始作为运行总和,`fold`获取`1..n+1`产生的每个值并应用闭包`|sum, item| sum + item`去运行总和和值.闭包的返回值被视为新的运行总和.它返回的最后一个值是`fold`本身返回的值--在这种情况下,是整个序列的总和.如果你习惯于`for`和`while`循环,这可能看起来很奇怪,但是一旦你习惯了它,`fold`是一个清晰易懂的替代方案.

这是函数式编程语言的标准功能,它非常注重表现力.但Rust的迭代器经过精心设计,以确保编译器能够将它们转换为出色的机器码.在之前显示的第二个定义的发布版本中,Rust知道`fold`的定义,并将其内联为`triangle`.接下来,闭包`|sum, item| sum + item`被内联到那里.最后,Rust检查组合代码并认识到有一种更简单的方法可以计算数字从1到`n`的总和:总和总是等于`n * (n+1) / 2`.Rust将整个`triangle`体,循环,闭包以及所有内容转换为单个乘法指令和一些其他位运算.

这个例子恰好涉及简单的算术,但迭代器在更重要的使用时也表现良好.它们是Rust提供灵活的抽象的另一个例子,在典型使用中几乎不会产生任何开销.

本章的其余部分分为五个部分:

- 首先我们将解释`Iterator`和`IntoIterator`traits,它们是Rust迭代器的基础.

- 然后我们将介绍典型迭代器管道的三个阶段:从某种值源创建迭代器;通过选择或处理值来调整一种迭代器到另一种迭代器;然后消费迭代器产生的值.

- 最后,我们将展示如何为你自己的类型实现迭代器.

有很多方法,所以一旦你有了大概的想法就可以浏览一个部分.但迭代器在惯用Rust中很常见,熟悉它们附带的工具对掌握语言至关重要.

## Iterator和IntoIterator Traits(Iterator and IntoIterator Traits)

迭代器是实现`std::iter::Iterator`trait的任何值:

```Rust
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
    ... // many default methods
}
```

`Item`是迭代器生成的值的类型.`next`方法要么返回`Some(v)`,其中`v`是迭代器的下一个值,要么返回`None`以指示序列的结束.这里我们省略了`Iterator`的许多默认方法;在本章的其余部分我们将单独介绍它们.

如果有一种自然的迭代某种类型的方式,它可以实现`std::iter::IntoIterator`,其`into_iter`方法接受一个值并在其上返回一个迭代器:

```Rust
trait IntoIterator where Self::IntoIter::Item == Self::Item {
    type Item;
    type IntoIter: Iterator;
    fn into_iter(self) -> Self::IntoIter;
}
```

`IntoIter`是迭代器值本身的类型,`Item`是它生成的值的类型.我们将实现`IntoIterator`的任何类型称为 *可迭代的(iterable)* ,因为如果你问的话,你可以迭代它.

Rust的`for`循环将所有这些部分很好地结合在一起.要迭代向量的元素,你可以编写:

```Rust
println!("There's:");
let v = vec!["antimony", "arsenic", "aluminum", "selenium"];

for element in &v {
    println!("{}", element);
}
```

在底层,每个`for`循环只是对`IntoIterator`和`Iterator`方法的调用的简写:

```Rust
let mut iterator = (&v).into_iter();
while let Some(element) = iterator.next() {
    println!("{}", element);
}
```

`for`循环使用`IntoIterator::into_iter`将其操作数`&v`转换为迭代器,然后重复调用`Iterator::next`.每次返回`Some(element)`时,`for`循环执行它的主体;如果它返回`None`,则循环结束.

虽然`for`循环总是在其操作数上调用`into_iter`,但你也可以直接将迭代器传递给`for`循环;例如,当你在`Range`上循环时会发生这种情况.所有迭代器都自动实现`IntoIterator`,使用一个简单地返回迭代器的`into_iter`方法.

如果在返回`None`之后再次调用迭代器的`next`方法,则`Iterator`trait不会指定它应该做什么.大多数迭代器只会再次返回`None`,但不是全部.(如果这样会导致问题,请参阅第338页的"保险(fuse)"中的`fuse`适配器.)

这是迭代器的一些术语:

- 正如我们所说, *迭代器(iterator)* 是实现`Iterator`的任何类型.

- *可迭代的(iterable)* 是实现`IntoIterator`的任何类型:你可以通过调用其`into_iter`方法获取迭代器.在这种情况下,向量引用`&v`是可迭代的.

- 迭代器 *生成(produces)* 值.

- 迭代器生成的值是 *项(items)* .这里的项是`"antimony"`,`"arsenic"`等.

- 接收迭代器生成的项的代码是 *消费者(consumer)* .在此示例中,`for`循环消费迭代器的项.

## 创建迭代器(Creating Iterators)

Rust标准库文档详细解释了每种类型提供的迭代器类型,但该库遵循一些通用约定来帮助你获得定向并找到所需内容.

### iter和iter_mut方法(iter and iter_mut Methods)

大多数集合类型提供`iter`和`iter_mut`方法,这些方法返回类型上的自然迭代器,从而生成每个项的共享或可变引用.像`&[T]`和`&str`这样的切片也有`iter`和`iter_mut`方法.如果你不打算让`for`循环为你处理它的话,这些方法是获取迭代器的最常用方法:

```Rust
let v = vec![4, 20, 12, 8, 6];
let mut iterator = v.iter();
assert_eq!(iterator.next(), Some(&4));
assert_eq!(iterator.next(), Some(&20));
assert_eq!(iterator.next(), Some(&12));
assert_eq!(iterator.next(), Some(&8));
assert_eq!(iterator.next(), Some(&6));
assert_eq!(iterator.next(), None);
```

这个迭代器的项类型是`&i32`:每次调用`next`都会产生对下一个元素的引用.直到我们到达向量的末尾.

每种类型都可以自由地实现`iter`和`iter_mut`,以任何最有意义的方式实现它的目的.`std::path::Path`上的`iter`方法返回一个迭代器,它一次产生一个路径组件:

```Rust
use std::ffi::OsStr;
use std::path::Path;

let path = Path::new("C:/Users/JimB/Downloads/Fedora.iso");
let mut iterator = path.iter();
assert_eq!(iterator.next(), Some(OsStr::new("C:")));
assert_eq!(iterator.next(), Some(OsStr::new("Users")));
assert_eq!(iterator.next(), Some(OsStr::new("JimB")));
...
```

此迭代器的项类型是`&std::ffi::OsStr`,它是操作系统调用接受的类型字符串的切片的借用.

### IntoIterator实现(IntoIterator Implementations)

当一个类型实现了`IntoIterator`时,你可以自己调用它的`into_iter`方法,就像`for`循环一样:

```Rust
// You should usually use HashSet, but its iteration order is
// nondeterministic, so BTreeSet works better in examples.
use std::collections::BTreeSet;
let mut favorites = BTreeSet::new();
favorites.insert("Lucy in the Sky With Diamonds".to_string());
favorites.insert("Liebesträume No. 3".to_string());

let mut it = favorites.into_iter();
assert_eq!(it.next(), Some("Liebesträume No. 3".to_string()));
assert_eq!(it.next(), Some("Lucy in the Sky With Diamonds".to_string()));
assert_eq!(it.next(), None);
```

大多数集合实际上提供了几个`IntoIterator`实现,用于共享引用,可变引用和移动:

- 给定对集合的 *共享引用(shared reference)* ,`into_iter`返回一个迭代器,该迭代器生成对其项的共享引用.例如,在前面的代码中,`(&favorites).into_iter()`将返回一个其`Item`类型为`&String`的迭代器.

- 给定对集合的 *可变引用(mutable reference)* ,`into_iter`返回一个迭代器,该迭代器生成对项的可变引用.例如,如果`vector`是某个`Vec<String>`,则调用`(&mut vector).into_iter()`将返回一个其`Item`类型为`&mut String`的迭代器.

- 当 *通过值(by value)* 传递集合时,`into_iter`返回一个迭代器,该迭代器获取集合的所有权并通过值返回项;项的所有权从集合移动到消费者,并且在此过程中消耗原始集合.例如,前面代码中的调用`favorites.into_iter()`返回一个迭代器,它通过值生成每个字符串;消费者接收每个字符串的所有权.当删除迭代器时,`BTreeSet`中剩余的任何元素也会被删除,并且该集的现在为空的外壳被丢弃.

由于`for`循环将`IntoIterator::into_iter`应用于其操作数,因此这三个实现创建了以下习惯用于迭代对集合的共享引用或可变引用,或者使用集合并获取其元素的所有权:

```Rust
for element in &collection { ... }
for element in &mut collection { ... }
for element in collection { ... }
```

这些中的每一个都只会调用此处列出的其中一个`IntoIterator`实现.

并非每种类型都提供所有三种实现.例如,`HashSet`,`BTreeSet`和`BinaryHeap`没有在可变引用上实现`IntoIterator`,因为修改它们的元素可能会违反类型的不变性:修改后的值可能具有不同的哈希值,或者对其相邻值进行不同的排序,因此修改它会使其位置不正确.其他类型确实支持突变,但只部分地支持.例如,`HashMap`和`BTreeMap`产生对其条目的值可变引用,但对它们的键仅共享引用,原因与之前给出的类似.

一般原则是迭代应该是高效且可预测的,因此不提供昂贵的或者可能表现出令人惊讶的行为的实现(例如,重新哈希已修改的`HashSet`条目,可能在稍后的迭代中重新访问它们),Rust完全省略它们.

切片实现三个`IntoIterator`变体中的两个;因为他们没有自己的元素,所以没有"通过值(by value)"的情况.相反,`to_iter`对于`&[T]`和`&mut [T]`返回迭代器,它产生对元素的共享引用和可变引用.如果你将底层切片类型`[T]`想象为某种类型的集合,则这非常适合整体模式.

你可能已经注意到前两个`IntoIterator`变体(对于共享引用和可变引用)等同于在引用的对象上调用`iter`或`iter_mut`.为什么Rust同时提供两种?

`IntoIterator`是使`for`循环工作的,所以这显然是必要的.但是当你没有使用`for`循环时,`favorites.iter()`比`(&favorites).into_iter()`更清晰.通过共享引用进行迭代是你经常需要的,因此`iter`和`iter_mut`对于其人体工程学仍然很有价值.

`IntoIterator`在泛型代码中也很有用:你可以使用类似`T: IntoIterator`的限制将类型变量`T`限制为可以迭代的类型.或者,你可以编写`T: IntoIterator<Item=U>`以进一步要求迭代生成特定类型`U`.例如,此函数从任何可以使用`"{: ?}"`格式打印其项的可迭代的中转储(dumps)值:

```Rust
use std::fmt::Debug;

fn dump<T, U>(t: T)
    where T: IntoIterator<Item=U>,
          U: Debug
{
    for u in t {
        println!("{:?}", u);
    }
}
```

你不能使用`iter`和`iter_mut`来编写这个泛型函数,因为它们不是任何trait的方法:大多数可迭代类型只是碰巧都有这些名称的方法.

### drain方法(drain Methods)

许多集合类型提供了一个`drain`方法,该方法接受对集合的可变引用,并返回将每个元素的所有权传递给消费者的迭代器.但是,与`into_iter()`方法不同,后者通过值获取集合并使用它,而`drain`只是借用一个对集合的可变引用,当迭代器被删除时,它会从集合中移除任何剩余的元素,并将其保留为空.

对于可以通过范围(range)索引的类型,如`String`,向量和`VecDeque`,`drain`方法需要移除一系列元素,而不是排空整个序列:

```Rust
use std::iter::FromIterator;

let mut outer = "Earth".to_string();
let inner = String::from_iter(outer.drain(1..4));

assert_eq!(outer, "Eh");
assert_eq!(inner, "art");
```

如果确实需要排空整个序列,请使用全范围的`..`作为参数.

### 其它迭代器源(Other Iterator Sources)

前面的部分主要涉及向量和`HashMap`等集合类型,但标准库中还有许多其他类型支持迭代.表15-1总结了更有趣的内容,但还有更多内容.我们将在专门针对特定类型的章节中更详细地介绍其中一些方法(即第16章,第17章和第18章).

*表15-1. 标准库中的其他迭代器*

|类型或trait|表达式|说明|
|:--|:--|:--|
|`std::ops::Range`|`1..10`|端点必须是可迭代的整数类型.范围包括起始值,并不包括结束值.|
|`std::ops::RangeFrom`|`1..`|无限次迭代.起始必须是整数.如果值达到类型的限制,可能会发生恐慌或溢出.|
|`Option<T>`|`Some(10).iter()`|行为类似于长度为0(`None`)或1(`Some(v)`)的向量.|
|`Vec<T>`,`&[T]`|`v.windows(16)`|从左到右生成给定长度的每个连续切片.窗口重叠.|
||`v.chunks(16)`|从左到右生成给定长度的非重叠连续切片.|
||`v.chunks_mut(1024)`|类似`chunks`,但切片是可变的.|
||`v.split(|byte| byte & 1 != 0)`|生成由与给定谓词匹配的元素分隔的切片.|
||`v.split_mut(...)`|类似上一个,但产生可变切片.|
||`v.rsplit(...)`|类似`split`,但是从右到左产生切片.|
||`v.splitn(n, ...)`|类似`split`,但最多产生`n`个切片.|
|`String`,`&str`|`s.bytes()`|生成UTF-8形式的字节|
||`s.chars()`|产生UTF-8表示的`char`.|
||`s.split_whitespace()`|按空格拆分字符串,并生成非空格字符的切片.|
||`s.lines()`|生成字符串行的切片.|
||`s.split('/')`|按给定模式拆分字符串,生成匹配之间的切片.模式可以是很多东西:字符,字符串,闭包.|
||`s.matches(char::is_numeric)`|生成与给定模式匹配的切片.|
|`std::collections::HashMap`,<br/>`std::collections::BTreeMap`|`map.keys()`,<br/>`map.values()`|生成对映射的键或值的共享引用.|
||`map.values_mut()`|生成对条目值的可变引用.|
|`std::collections::HashSet`,<br/>`std::collections::BTreeSet`|`set1.union(set2)`|生成对`set1`和`set2`的并集元素的共享引用.|
||`set1.intersection(set2)`|生成对`set1`和`set2`的交集元素的共享引用.|
|`std::sync::mpsc::Receiver`|`recv.iter()`|生成从相应`Sender`的另一个线程发送的值.|
|`std::io::Read`|`stream.bytes()`|从I/O流生成字节|
||`stream.chars()`|解析流为UTF-8并产生`char`|
|`std::io::BufRead`|`bufstream.lines()`|解析流为UTF-8,生成行作为`String`|
||`bufstream.split(0)`|在给定字节上拆分流,产生字节间( inter-byte)`Vec<u8>`缓冲区.|
|`std::fs::ReadDir`|`std::fs::read_dir(path)`|生成目录条目.|
|`std::net::TcpListener`|`listener.incoming()`|生成传入的网络连接.|
|`Free functions`|`std::iter::empty()`|立即返回`None`.|
||`std::iter::once(5)`|生成给定值,然后结束.|
||`std::iter::repeat("#9")`|永远产生给定的值|

## 迭代器适配器(Iterator Adapters)

一旦掌握了迭代器,`Iterator`trait提供了广泛的 *适配器方法(adapter methods)* 选择,或者只是 *适配器(adapters)* ,它们消费一个迭代器并构建一个具有有用行为的新迭代器.要了解适配器的工作原理,我们将展示如何使用两个最受欢迎的适配器.

### map和filter(map and filter)

`Iterator`trait的`map`适配器允许你通过对其项应用闭包来转换迭代器.`filter`适配器允许你从迭代器中过滤掉项,使用闭包来决定保留哪些项以及删除哪些项.

例如,假设你正在迭代文本行,并且想要省略每行的前导和尾随空格.标准库的`str::trim`方法从单个`&str`中删除前导和尾随空格,返回一个新的,修剪过的`&str`,它从原始中借用.你可以使用`map`适配器将`str::trim`应用于迭代器中的每一行:

```Rust
let text = "  ponies  \n   giraffes\niguanas  \nsquid".to_string();
let v: Vec<&str> = text.lines()
    .map(str::trim)
    .collect();
assert_eq!(v, ["ponies", "giraffes", "iguanas", "squid"]);
```

`text.lines()`调用返回一个生成字符串行的迭代器.在该迭代器上调用`map`将返回第二个迭代器,该迭代器将`str::trim`应用于每一行,并将结果作为其项生成. 最后,`collect`将这些项收集到一个向量中.

当然,迭代器`map`返回本身就是进一步适应的候选者.如果要从结果中排除鬣蜥(iguanas),可以编写以下内容:

```Rust
let text = "  ponies  \n   giraffes\niguanas  \nsquid".to_string();
let v: Vec<&str> = text.lines()
    .map(str::trim)
    .filter(|s| *s != "iguanas")
    .collect();
assert_eq!(v, ["ponies", "giraffes", "squid"]);
```

这里,`filter`返回第三个迭代器,它只生成`map`迭代器中的使闭包`|s| *s != "iguanas"`返回`true`的那些项.迭代器适配器链就像Unix shell中的管道:每个适配器都有一个单一的目的,当从左到右读取时,很清楚如何转换序列.

这些适配器的签名如下:

```Rust
fn map<B, F>(self, f: F) -> some Iterator<Item=B>
    where Self: Sized, F: FnMut(Self::Item) -> B;

fn filter<P>(self, predicate: P) -> some Iterator<Item=Self::Item>
    where Self: Sized, P: FnMut(&Self::Item) -> bool;
```

我们用于返回类型的`some Iterator <...>`表示法是无效Rust(代码)[^1].真正的返回类型是不透明的`struct`类型,它们不提供信息;在实践中最重要的是这些方法返回具有给定`Item`类型的迭代器.

由于大多数适配器都是通过值接受`self`,因此它们要求`Self`是`Sized`(所有常见的迭代器都是).

`map`迭代器通过值将每个项传递给它的闭包,然后将闭包结果的所有权传递给它的消费者.`filter`迭代器通过共享引用将每个项传递给其闭包,在选择将项传递给其消费者时保留所有权.这就是为什么示例必须解引用`s`以将其与`"iguanas"`进行比较的原因:`filter`迭代器的项类型是`&str`,因此闭包的参数`s`的类型是`&&str`.

关于迭代器适配器,有两点需要注意.

首先,简单地在迭代器上调用适配器不会消耗任何项目;它只返回一个新的迭代器,准备根据需要通过从第一个迭代器中提取元素来生成自己的项.在适配器链中,实际完成任何工作的唯一方法是在最终迭代器上调用`next`.

所以在前面的例子中,方法调用`text.lines()`本身实际上并不解析字符串中的任何行;它只返回一个迭代器,如果请求到,它 *将(would)* 解析行.类似地,`map`和`filter`只返回新迭代器,如果要求到,它 *将(would)* 映射或过滤.在`collect`开始在`filter`迭代器上调用`next`之前,不会发生任何工作.

[^1]: Rust RFC1522将为语言添加语法,非常像我们的`some Iterator`表示法.在Rust 1.17中,它还没有被默认包含在语言中.

如果你使用有副作用的适配器,这一点尤为重要.例如,此代码根本不打印任何内容:

```Rust
["earth", "water", "air", "fire"]
    .iter().map(|elt| println!("{}", elt));
```

`iter`调用返回一个数组的元素上的迭代器,`map`调用返回第二个迭代器,它将闭包应用于第一个迭代器生成的每个值.但是这里没有任何东西真正需要整个链的值,所以没有`next`方法会运行.事实上,Rust会警告你:

```Rust
warning: unused result which must be used:
iterator adaptors are lazy and do nothing unless consumed
    |
387 | /         ["earth", "water", "air", "fire"]
388 | |             .iter().map(|elt| println!("{}", elt));
    | |___________________________________________________^
    |
= note: #[warn(unused_must_use)] on by default
```

错误消息中的术语"lazy(懒惰)"不是一个贬义词;它只是任何一种将计算推迟到需要其值时的机制的术语.Rust的惯例是,迭代器应该做最少的工作来满足对`next`的每次调用;在这个示例中,根本没有这样的调用,因此不进行任何工作.

第二个重点是迭代器适配器是零开销抽象.由于`map`,`filter`及它们的同伴是泛型的,因此将它们应用到迭代器上,可以为所涉及的特定迭代器类型提供专门的代码.这意味着Rust有足够的信息,可以将每个迭代器的`next`方法内联到其使用者中,然后将整个安排为一个单元转换为机器码.所以,我们之前展示的迭代器的`lines`/`map`/`filter`链和你手工可能编写的代码一样高效:

```Rust
for line in text.lines() {
    let line = line.trim();
    if line != "iguanas" {
        v.push(line);
    }
}
```

本节的其余部分介绍`Iterator`trait上可用的各种适配器.

### filter_map和flat_map(filter_map and flat_map)

在每个传入项生成一个传出项的情况下,`map`适配器很好.但是,如果你想从迭代中删除某些项而不是处理它们,或者用零个或多个项替换单个项,该怎么办?`filter_map`和`flat_map`适配器为你提供了这种灵活性.

`filter_map`适配器类似于`map`,除了它允许其闭包将项转换为新项(如`map`那样)或从迭代中删除项.因此,它有点像`filter`和`map`的组合.其签名如下:

```Rust
fn filter_map<B, F>(self, f: F) -> some Iterator<Item=B>
    where Self: Sized, F: FnMut(Self::Item) -> Option<B>;
```

这与`map`的签名相同,除了这里闭包返回`Option<B>`,而不是简单的`B`.当闭包返回`None`时,该项将从迭代中删除;当它返回`Some(b)`时,则`b`是`filter_map`迭代器产生的下一个项.

例如,假设你要扫描字符串以查找可以解析为数字的空格分隔的单词,并处理数字,删除其他单词.你可以写:

```Rust
use std::str::FromStr;

let text = "1\nfrond .25  289\n3.1415 estuary\n";

for number in text.split_whitespace()
                  .filter_map(|w| f64::from_str(w).ok()) {
    println!("{:4.2}", number.sqrt());
}
```

这将打印以下内容:

```Rust
1.00
0.50
17.00
1.77
```

给`filter_map`的闭包尝试使用`f64::from_str`解析每个空格分隔的切片.返回`Result<f64, ParseFloatError>`,其中`.ok()`变为`Option<f64>`:解析错误变为`None`,而成功的解析结果变为`Some(v)`.`filter_map`迭代器删除所有`None`值,并为每个`Some(v)`生成值`v`.

但是将`map`和`filter`融合到这样的单个操作中的重点是什么,而不是直接使用这些适配器?`filter_map`适配器在刚刚展示的情况下显示其值,此时决定是否在迭代中包含项的最佳方法是实际尝试处理它.你可以只使用`filter`和`map`做同样的事情,但它有点笨拙:

```Rust
text.split_whitespace()
    .map(|w| f64::from_str(w))
    .filter(|r| r.is_ok())
    .map(|r| r.unwrap())
```

你可以将`flat_map`适配器看作与`map`和`filter_map`相同的结构,只是现在闭包不仅可以返回一个项目(如`map`)或零或一个项目(如`filter_map`),还可以返回任意数量的项的序列.`flat_map`迭代器生成闭包返回的序列的连接.

`flat_map`的签名如下:

```Rust
fn flat_map<U, F>(self, f: F) -> some Iterator<Item=U::Item>
    where F: FnMut(Self::Item) -> U, U: IntoIterator;
```

传递给`flat_map`的闭包必须返回一个可迭代的,但任何类型的可迭代的都可以.[^2]

例如,假设我们有一个表格将国家映射到它们的主要城市.给定一个国家名单,我们如何迭代它们的主要城市?

```Rust
use std::collections::HashMap;

let mut major_cities = HashMap::new();
major_cities.insert("Japan", vec!["Tokyo", "Kyoto"]);
major_cities.insert("The United States", vec!["Portland", "Nashville"]);
major_cities.insert("Brazil", vec!["São Paulo", "Brasília"]);
major_cities.insert("Kenya", vec!["Nairobi", "Mombasa"]);
major_cities.insert("The Netherlands", vec!["Amsterdam", "Utrecht"]);

let countries = ["Japan", "Brazil", "Kenya"];

for &city in countries.iter().flat_map(|country| &major_cities[country]) {
    println!("{}", city);
}
```

这将打印以下内容:

```Rust
Tokyo
Kyoto
São Paulo
Brasília
Nairobi
Mombasa
```

一种看待这种情况的方法是,对于每个国家,我们检索其城市的向量,将所有向量连接在一起成为单个序列,并打印出来.

但请记住,迭代器是惰性的:它只是`for`循环对`flat_map`迭代器的`next`方法的调用,导致工作完成.完整的连接序列从来没有在内存中构建.相反,我们这里有一个小型状态机,它从城市迭代器中抽取,一次一项,直到它耗尽,然后才为下一个国家生成一个新的城市迭代器.效果是一个嵌套循环,但打包用作迭代器.

[^2]: 实际上,由于`Option`是一个可迭代的,行为就像一个零个或一个项的序列, `iterator.filter_map(closure)`等效于`iterator.flat_map(closure)`,假设闭包返回一个`Option<T>`.

### scan(scan)

`scan`适配器类似于`map`,只是闭包被赋予它可以参考的可变值,并且有提前终止迭代的选项.它接受一个初始状态值,然后是一个接受对状态的可变引用的闭包,以及来自底层迭代器的下一个项.闭包必须返回一个`Option`,`scan`迭代器将其作为下一个项.

例如,这是一个迭代器链,它对另一个迭代器的项进行平方,并在它们的总和超过10时终止迭代:

```Rust
let iter = (0..10)
    .scan(0, |sum, item| {
        *sum += item;
        if *sum > 10 {
            None
        } else {
            Some(item * item)
        }
    });

assert_eq!(iter.collect::<Vec<i32>>(), vec![0, 1, 4, 9, 16]);
```

闭包的`sum`参数是对迭代器私有的值的可变引用,并初始化为`scan`的第一个参数--在本例中为`0`.闭包更新`*sum`,检查它是否已超出限制,并返回迭代器的下一个结果.

### take和take_while(take and take_while)

`Iterator`trait的`take`和`take_while`适配器允许你在一定数量的项之后结束迭代,或者当一个闭包决定关闭时.他们的签名如下:

```Rust
fn take(self, n: usize) -> some Iterator<Item=Self::Item>
    where Self: Sized;

fn take_while<P>(self, predicate: P) -> some Iterator<Item=Self::Item>
    where Self: Sized, P: FnMut(&Self::Item) -> bool;
```

两者都获取迭代器的所有权并返回一个新的迭代器,该迭代器传递来自第一个的项,可能会提前结束序列.生成最多`n`个项,`take`迭代器返回`None`.`take_while`迭代器将`predicate`应用于每个项,并返回`None`代替`predicate`返回`false`的第一个项,以及每次后续调用`next`.

例如,给定一封电子邮件消息,其中有一个空行将标题和消息正文分开,你可以使用`take_while`迭代标题:

```Rust
let message = "To: jimb\r\n\
               From: superego <editor@oreilly.com>\r\n\
               \r\n\
               Did you get any writing done today?\r\n\
               When will you stop wasting time plotting fractals?\r\n";
for header in message.lines().take_while(|l| !l.is_empty()) {
    println!("{}" , header);
}
```

回想一下第64页的"字符串字面量(String Literals)",当字符串中的一行以反斜杠结尾时,Rust不包含字符串中下一行的缩进,因此字符串中没有任何行具有任何前导空格.这意味着`message`的第三行是空白的.`take_while`适配器在看到该空行时立即终止迭代,因此此代码仅打印两行:

```Rust
To: jimb
From: superego <editor@oreilly.com>
```

### skip和skip_while(skip and skip_while)

`Iterator`trait的`skip`和`skip_while`方法是`take`和`take_while`的补充:它们从迭代开始时删除一定数量的项,或者删除项直到闭包找到一个可接受的项,然后将其余项目保持不变.它们的签名如下:

```Rust
fn skip(self, n: usize) -> some Iterator<Item=Self::Item>
    where Self: Sized;

fn skip_while<P>(self, predicate: P) -> some Iterator<Item=Self::Item>
    where Self: Sized, P: FnMut(&Self::Item) -> bool;
```

`skip`适配器的一个常见用途是在迭代程序的命令行参数时跳过命令名.在第2章中,我们最大的公约数计算器使用以下代码循环其命令行参数:

```Rust
for arg in
 std::env::args().skip(1) {
    ...
}
```

`std::env::args`函数返回一个迭代器,它将程序的参数生成为`String`,第一个项是程序本身的名称.那不是我们想要在这个循环中处理的字符串.在该迭代器上调用`skip(1)`将返回一个新的迭代器,该迭代器在第一次调用时删除程序名,然后生成所有后续参数.

`skip_while`适配器使用闭包来决定从序列开头删除多少项.你可以迭代上一节中消息的正文行,如下所示:

```Rust
for body in message.lines()
    .skip_while(|l| !l.is_empty())
    .skip(1) {
    println!("{}" , body);
}
```

这使用`skip_while`来跳过非空行,但是迭代器确实产生了空白行--毕竟,该行的闭包返回`false`.所以我们也使用`skip`方法来删除它,给我们一个迭代器,它的第一个项将是消息体的第一行.与上一节的`message`声明一起,此代码打印:

```Rust
Did you get any writing done today?
When will you stop wasting time plotting fractals?
```

### peekable(peekable)

一个可窥探(peekable)的迭代器可以让你偷看将生成的下一个项,而不会实际消耗它.你可以通过调用`Iterator`trait的`peekable`方法将几乎所有迭代器转换为可窥探的迭代器:

```Rust
fn peekable(self) -> std::iter::Peekable<Self>
    where Self: Sized;
```

这里,`Peekable<Self>`是一个实现`Iterator<Item=Self::Item>`的`struct`,`Self`是底层迭代器的类型.

`Peekable`迭代器有一个额外的方法`peek`,返回一个`Option<&Item>`:如果底层迭代器完成则返回`None`,否则返回`Some(r)`其中`r`是对下一个项的共享引用.(注意,如果迭代器的项类型已经是某个东西的引用,那么这最终会成为对引用的引用.)

调用`peek`尝试从底层迭代器中拉取下一个项,如果有,则将其缓存直到下一次调用`next`.`Peekable`上的所有其他`Iterator`方法都知道这个缓存:例如,可窥探迭代器`iter`上的`iter.last()`知道在耗尽底层迭代器后检查缓存.

当你在走得太远之前,无法决定从迭代器中消耗多少项时,可窥探迭代器是必不可少的.例如,如果你要解析字符流中的数字,则在看到后面的第一个非数字字符之前,你无法确定数字的结束位置:

```Rust
use std::iter::Peekable;

fn parse_number<I>(tokens: &mut Peekable<I>) -> u32
    where I: Iterator<Item=char>
{
    let mut n = 0;
    loop {
        match tokens.peek() {
            Some(r) if r.is_digit(10) => {
                n = n * 10 + r.to_digit(10).unwrap()
            }
            _ => return n
        }
        tokens.next();
    }
}

let mut chars = "226153980,1766319049".chars().peekable();
assert_eq!(parse_number(&mut chars), 226153980);
// Look, `parse_number` didn't consume the comma! So we will.
assert_eq!(chars.next(), Some(','));
assert_eq!(parse_number(&mut chars), 1766319049);
assert_eq!(chars.next(), None);
```

`parse_number`函数使用`peek`来检查下一个字符,只有当它是一个数字时才使用它.如果它不是数字或迭代器耗尽(即,如果`peek`返回`None`),我们返回我们解析的数字并将下一个字符留在迭代器中,等待使用.

### fuse(fuse)

一旦`Iterator`返回`None`,如果再次调用`next`方法,该trait就不会指定它行为应该怎样.大多数迭代器只返回`None`,但不是全部.如果你的代码依赖于该行为,你可能会感到惊讶.

`fuse`适配器接受任何迭代器并转为一个,一旦它第一次完成,肯定会继续返回`None`:

```Rust
struct Flaky(bool);

impl Iterator for Flaky {
    type Item = &'static str;
    fn next(&mut self) -> Option<Self::Item> {
        if self.0 {
            self.0 = false;
            Some("totally the last item")
        } else {
            self.0 = true; // D'oh!
            None
        }
    }
}

let mut flaky = Flaky(true);
assert_eq!(flaky.next(), Some("totally the last item"));
assert_eq!(flaky.next(), None);
assert_eq!(flaky.next(), Some("totally the last item"));

let mut not_flaky = Flaky(true).fuse();
assert_eq!(not_flaky.next(), Some("totally the last item"));
assert_eq!(not_flaky.next(), None);
assert_eq!(not_flaky.next(), None);
```

`fuse`适配器可能在需要使用不确定来源的迭代器的泛型代码中最有用.而不是希望你必须处理的每个迭代器都表现良好,你可以使用`fuse`来确保.

### 可逆的迭代器和rev(Reversible Iterators and rev)

一些迭代器能够从序列的两端拉取项.你可以使用`rev`适配器来反转此类迭代器.例如,向量上的迭代器可以像从头开始一样容易地从向量的末尾拉取项.这样的迭代器可以实现`std::iter::DoubleEndedIterator`特性,它扩展了`Iterator`:

```Rust
trait DoubleEndedIterator: Iterator {
    fn next_back(&mut self) -> Option<Self::Item>;
}
```

你可以把双端迭代器看成是有两个手指标记序列的当前正面和背面.从任一端拉取项将手指推向另一端;当两者相遇时,迭代完成:

```Rust
use std::iter::DoubleEndedIterator;

let bee_parts = ["head", "thorax", "abdomen"];

let mut iter = bee_parts.iter();
assert_eq!(iter.next(),      Some(&"head"));
assert_eq!(iter.next_back(), Some(&"abdomen"));
assert_eq!(iter.next(),      Some(&"thorax"));

assert_eq!(iter.next_back(), None);
assert_eq!(iter.next(),      None);
```

切片上的迭代器结构体使得这种行为易于实现:它实际上是一对指向我们尚未生成的元素范围的开始和结束的指针;`next`和`next_back`只是从一个或另一个中拉取一个项.有序集合(如`BTreeSet`和`BTreeMap`)的迭代器也是双端的:它们的`next_back`方法首先拉取最大的元素或条目.通常,标准库在任何实际情况下都提供双端迭代.

但并非所有迭代器都可以这么容易地做到这一点:从其他线程到达通道的`Receiver`生成值的迭代器无法预测最后接收到的值可能是什么.通常,你需要检查标准库的文档,以查看哪些迭代器实现了`DoubleEndedIterator`,哪些没有.

如果迭代器是双端的,你可以使用`rev`适配器将其反转:

```Rust
fn rev(self) -> some Iterator<Item=Self>
    where Self: Sized + DoubleEndedIterator;
```

返回的迭代器也是双端的:它的`next`和`next_back`方法只是交换:

```Rust
let meals = ["breakfast", "lunch", "dinner"];

let mut iter = meals.iter().rev();
assert_eq!(iter.next(), Some(&"dinner"));
assert_eq!(iter.next(), Some(&"lunch"));
assert_eq!(iter.next(), Some(&"breakfast"));
assert_eq!(iter.next(), None);
```

大多数迭代器适配器,如果应用于可逆迭代器,则返回另一个可逆迭代器.例如,`map`和`filter`保留可逆性.

### inspect(inspect)

`inspect`适配器用于调试迭代器适配器的管道,但在生产代码中使用不多.它只是将闭包应用于每个项的共享引用,然后传递该项.闭包不会影响项,但它可以执行打印或对它们进行断言等操作.

此示例显示将字符串转换为大写更改其长度的情况:

```Rust
let upper_case: String = "große".chars()
    .inspect(|c| println!("before: {:?}", c))
    .flat_map(|c| c.to_uppercase())
    .inspect(|c| println!(" after:     {:?}", c))
    .collect();
assert_eq!(upper_case, "GROSSE");
```

小写德语字母"ß"的大写等价物是"SS",这就是`char::to_uppercase`返回字符迭代器,而不是单个替换字符的原因.上面的代码使用`flat_map`连接`to_uppercase`返回的所有序列为一个单个的`String`,打印为以下内容:

```Rust
before: 'g'
 after:     'G'
before: 'r'
 after:     'R'
before: 'o'
 after:     'O'
before: 'ß'
 after:     'S'
 after:     'S'
before: 'e'
 after:     'E'
```

### chain(chain)

`chain`适配器将一个迭代器附加到另一个迭代器.更准确地说,`i1.chain(i2)`返回一个迭代器,它从`i1`中拉取项直到它耗尽,然后从`i2`中拉取项.

`chain`适配器的签名如下:

```Rust
fn chain<U>(self, other: U) -> some Iterator<Item=Self::Item>
    where Self: Sized, U: IntoIterator<Item=Self::Item>;
```

换句话说,你可以将迭代器与任何生成相同项类型的迭代链接在一起.

例如:

```Rust
let v: Vec<i32> = (1..4).chain(vec![20, 30, 40]).collect();
assert_eq!(v, [1, 2, 3, 20, 30, 40]);
```

`chain`迭代器是可逆的.如果它的两个底层迭代器都是可逆的:

```Rust
let v: Vec<i32> = (1..4).chain(vec![20, 30, 40]).rev().collect();
assert_eq!(v, [40, 30, 20, 3, 2, 1]);
```

`chain`迭代器跟踪两个底层迭代器中的每一个是否返回`None`,并根据需要将`next`和`next_back`调用指向其中一个或另一个.

### enumerate(enumerate)

`Iterator`trait的`enumerate`适配器将一个运行索引附加到序列,使用生成项`A, B, C, ...`的迭代器并返回生成对`(0, A), (1, B), (2, C)`的迭代器.乍一看看起来微不足道,但经常出人意料地使用它.

消费者可以使用该索引将一个项与另一个项区分开来,并建立处理每个项的上下文.例如,第2章中的Mandelbrot集绘图器将图像分成8个水平条带,并将每个条带分配给不同的线程.该代码使用`enumerate`来告诉每个线程图像的哪个条带对应于它.

从矩形像素缓冲区开始:

```Rust
let mut pixels = vec![0; columns * rows];
```

它使用`chunks_mut`将图像分割成水平带,每个线程一个:

```Rust
let threads = 8;
let band_rows = rows / threads + 1;
...
let bands: Vec<&mut [u8]> = pixels.chunks_mut
(band_rows * columns).collect();
```

然后它遍历各个带,为每个带启动一个线程:

```Rust
for (i, band) in bands.into_iter().enumerate() {
    let top = band_rows * i;
    // start a thread to render rows `top..top + band_rows`
}
```

每次迭代都得到一对(i, band),其中`band`是线程应该绘制的像素缓冲区的`&mut [u8]`切片,`i`是整个图像中该条带的索引,由`enumerate`适配器提供.给定绘图的边界和条带的大小,这就足够让线程确定它已被分配图像的哪个部分,从而确定要绘制到条带中的内容.

### zip(zip)
