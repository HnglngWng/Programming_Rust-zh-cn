# 字符串和文本

> 字符串是一个刻板的数据结构,在任何地方传递它都有很多重复的过程.它是隐藏信息的完美工具.
> --Alan Perlis,  epigram #34

原文

> The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
> --Alan Perlis, epigram #34

在本书中,我们一直在使用Rust的主要文本类型,`String`,`str`和`char`.在第64页的"字符串类型(String Types)"中,我们描述了字符和字符串字面量的语法,并展示了字符串在内存中的表示方式.在本章中,我们将更详细地介绍文本处理.

在这一章当中:

- 我们为你提供有关Unicode的背景知识,可帮助你了解标准库的设计.

- 我们描述了`char`类型,表示单个Unicode代码点.

- 我们描述`String`和`str`类型,表示拥有和借用的Unicode字符序列.它们有各种用于构建,搜索,修改和迭代其内容的方法.

- 我们涵盖Rust的字符串格式化工具,如`println!`和`format!`宏.你可以编写自己的宏来处理格式化字符串,并扩展它们以支持你自己的类型.

- 我们概述了Rust的正则表达式支持.

- 最后,我们讨论为什么Unicode规范化很重要,并展示如何在Rust中执行它.

## 一些Unicode背景知识(Some Unicode Background)

这本书是关于Rust的,而不是Unicode,它已经有很多关于它的书了.但Rust的字符和字符串类型是围绕Unicode设计的.以下是一些有助于解释Rust的Unicode.

### ASCII,Latin-1,和Unicode(ASCII, Latin-1, and Unicode)

Unicode和ASCII匹配所有ASCII的代码点,从`0`到`0x7f`:例如,两者都为字符`'*'`分配代码点`42`.类似地,Unicode将`0`到`0xff`分配给与ISO/IEC 8859-1字符集相同的字符,这是用于西欧语言的ASCII的8位超集.Unicode将此范围的代码点称为 *Latin-1代码块(Latin-1 code block)* ,因此我们将通过更令人回味的名称 *Latin-1* 来引用ISO/IEC 8859-1.

由于Unicode是Latin-1的超集,因此将Latin-1转换为Unicode甚至不需要表:

```Rust
fn latin1_to_char(latin1: u8) -> char {
    latin1 as char
}
```

假设代码点落在Latin-1范围内,反向转换也是微不足道的:

```Rust
fn char_to_latin1(c: char) -> Option<u8> {
    if c as u32 <= 0xff {
        Some(c as u8)
    } else {
        None
    }
}
```

### UTF-8

Rust的`String`和`str`类型使用UTF-8编码形式表示文本.UTF-8将字符编码为1到4个字节的序列(图17-1).

*图17-1. UTF-8编码*

对格式良好的UTF-8序列有两个限制.首先,只考虑任何给定代码点的最短编码;你不能花四个字节来编码一个适合三个的代码点.此规则确保给定代码点只有一个UTF-8编码.其次,格式良好的UTF-8不能编码从`0xd800`到`0xdfff`或超过`0x10ffff`的数字:这些数字要么保留用于非字符目的,要么完全在Unicode范围之外.

图17-2显示了一些示例.

*图17-2. UTF-8示例*

请注意,即使蟹表情符号(carb emoji)的编码,其前导字节仅对代码点贡献零,它仍然需要四字节编码:三字节UTF-8编码只能传送16位代码点,而`0x1f980`是17位长.

这是一个字符串的快速示例,其中包含具有不同长度编码的字符:

```Rust
assert_eq!("うどん: udon".as_bytes(),
           &[0xe3, 0x81, 0x86, // う
             0xe3, 0x81, 0xa9, // ど
             0xe3, 0x82, 0x93, // ん
             0x3a, 0x20, 0x75, 0x64, 0x6f, 0x6e // : udon
           ]);
```

该图显示了UTF-8的一些非常有用的属性:

- 由于UTF-8将代码点`0`到`0x7f`编码为不超字节`0`到`0x7f`,因此保存ASCII文本的字节范围是有效的UTF-8.如果UTF-8字符串仅包含ASCII字符,则反之亦然:UTF-8编码是有效的ASCII.

对于Latin-1也不是这样:例如,Latin-1将`'é'`编码为字节`0xe9`,UTF-8将其解释为三字节编码的第一个字节.

- 通过查看任何字节的高位.你可以立即判断它是某个字符的UTF-8编码的开头,还是来自其中一个字节.

- 编码的第一个字节单独通过其前导位告诉你编码的全长.

- 由于编码不超过四个字节,因此UTF-8处理永远不需要无界循环,这在处理不可信的数据时很好.

- 在格式良好的UTF-8中,即使从字节中间的随机点开始,你也可以可以清楚地知道字符编码的开始和结束位置.UTF-8的第一个字节和后面的字节总是不同的,因此一个编码不能在另一个编码中间开始.第一个字节确定编码的总长度,因此没有编码可以是另一个的前缀.这有很多好的结果.例如,在UTF-8字符串中搜索ASCII分隔符字符只需要对分隔符的字节进行简单扫描.它永远不会出现在多字节编码的任何部分,因此根本不需要跟踪UTF-8结构.类似地,在另一个字节串中搜索一个字节字符串的算法将在不修改UTF-8字符串的情况下工作,即使有些算法甚至不检查正在搜索的文本的每个字节.

尽管可变宽度编码比固定宽度编码更复杂,但这些特性使得UTF-8的使用比你预期的更加舒适.标准库为你处理大多数方面.

### 文本方向性(Text Directionality)

而拉丁语,西里尔语和泰语等手稿是从左到右书写的,其他手稿如希伯来语和阿拉伯语则是从右到左书写的.Unicode按照通常写入或读取的顺序存储字符,因此保存希伯来语文本的字符串的初始字节编码将在右侧写入的字符:

```Rust
assert_eq!("ערב טוב".chars().next(), Some('ע'));
```

标准库中的一些方法名称使用术语`left`和`right`来表示文本的开头和结尾.当我们描述这些函数时,我们将详细说明他们实际做了什么.

## 字符(char)(Characters (char))

Rust`char`是一个包含Unicode代码点的32位值.保证`char`在`0`到`0xd7ff`的范围内,或者在`0xe000`到`0x10ffff`的范围内;所有创建和操作`char`值的方法都确保这是真的.`char`类型实现了`Copy`和`Clone`,以及用于比较,哈希和格式化的所有常用trait.

在下面的描述中,变量`ch`始终是`char`类型.

### 字符分类(Classifying Characters)

`char`类型具有将字符分类为几个常见类别的方法.这些都是从Unicode中得出它们的定义,如表17-0所示.

|方法|描述|示例|
|:--|:--|:--|
|`ch.is_numeric()`|一个数字字符.这包括Unicode常规类别"Number;digit"和"Number;letter",但不是"Number;other".|`'4'.is_numeric()`<br/>`'ᛮ'.is_numeric()`<br/>`!'⑧'.is_numeri()`|
|`ch.is_alphabetic()`|字母字符:Unicode的"字母(Alphabetic)"派生属性.|`'q'.is_alphabetic()`<br/>`'七'.is_alphabetic()`|
|`ch.is_alphanumeric()`|数字或字母,如上所定义|`'9'.is_alphanumeric()`<br/>`'饂'.is_alphanumeric()`<br/>`!'*'.is_alphanumeric()`|
|`ch.is_whitespace()`|空白字符:Unicode字符属性"WSpace=Y".|`' '.is_whitespace()`<br/>`'\n'.is_whitespace()`<br/>`'\u{A0}'.is_whitespace()`|
|`ch.is_control()`|控制字符:Unicode的"Other,control"常规类别.|`'\n'.is_control()`<br/>`'\u{85}'.is_control()`|

### 处理数字(Handling Digits)

对于处理数字,你可以使用以下方法:

- `ch.to_digit(radix)`决定`ch`是否为基数`radix`的数字.如果是,则返回`Some(num)`,其中`num`是`u32`.否则,它返回`None`.这仅识别ASCII数字,而不识别`char::is_numeric`所涵盖的更广泛的字符类.`radix`参数的范围为2到36.对于大于10的基数,任一情况的ASCII字母都被视为数字,值为10到35.

- 如果可能,自由函数`std::char::from_digit(num, radix)`将`u32`数字值`num`转换为`char`.如果`num`可以用`radix`表示为单个数字,`from_digit`返回`Some(ch)`,其中`ch`是数字.当`radix`大于10时,`ch`可以是小写字母.否则,它返回`None`.

这与`to_digit`相反.如果`std::char::from_digit(num, radix)`是`Some(ch)`,则`ch.to_digit(radix)`是`Some(num)`.如果`ch`是ASCII数字或小写字母,则反之亦然.

- `ch.is_digit(radix)`,如果`ch`是基数`radix`的ASCII数字,则返回`true`.这相当于`ch.to_digit(radix) != None`.

所以,例如:

```Rust
assert_eq!('F'.to_digit(16), Some(15));
assert_eq!(std::char::from_digit(15, 16), Some('f'));
assert!(char::is_digit('f', 16));
```

### 字符的大小写转换(Case Conversion for Characters)

处理字符案例:

- `ch.is_lowercase()`和`ch.is_uppercase()`指示`ch`是小写字母还是大写字母.它们遵循Unicode的小写(Lowercase)和大写(Uppercase)派生属性,因此它们涵盖非拉丁字母表,如希腊语和西里尔语,并为ASCII提供预期的结果.

- `ch.to_lowercase()`和`ch.to_uppercase()`返回根据Unicode默认大小写转换算法生成`ch`等效的大写和小写字符的字符的迭代器:

```Rust
let mut upper = 's'.to_uppercase();
assert_eq!(upper.next(), Some('S'));
assert_eq!(upper.next(), None);
```

这些方法返回迭代器而不是单个字符,因为Unicode中的大小写转换并不总是一对一的过程:

```Rust
// The uppercase form of the German letter "sharp S" is "SS":
let mut upper = 'ß'.to_uppercase();
assert_eq!(upper.next(), Some('S'));
assert_eq!(upper.next(), Some('S'));
assert_eq!(upper.next(), None);

// Unicode says to lowercase Turkish dotted capital 'İ' to 'i'
// followed by `'\u{307}'`, COMBINING DOT ABOVE, so that a
// subsequent conversion back to uppercase preserves the dot.
let ch = 'İ'; // `'\u{130}'`
let mut lower = ch.to_lowercase();
assert_eq!(lower.next(), Some('i'));
assert_eq!(lower.next(), Some('\u{307}'));
assert_eq!(lower.next(), None);
```

为方便起见,这些迭代器实现了`std::fmt::Display`trait,因此你可以将它们直接传递给`println!`或`write!`宏.

### 转换为整数和从整数转换(Conversions to and from Integers)

Rust的`as`运算符将`char`转换为任何整数类型,静默掩盖任何高位:

```Rust
assert_eq!('B' as u32, 66);
assert_eq!('饂' as u8, 66);   // upper bits truncated
assert_eq!('二' as i8, -116); // same
```

`as`运算符将任何`u8`值转换为`char`,而`char`也实现`From<u8>`,但更宽的整数类型可以表示无效的代码点,因此对于那些必须使用`std::char::from_u32`,它返回`Option<char>`:

```Rust
assert_eq!(char::from(66), 'B');
assert_eq!(std::char::from_u32(0x9942), Some('饂'));
assert_eq!(std::char::from_u32(0xd800), None); // reserved for UTF-16
```

### String和str(String and str)

Rust的`String`和`str`类型保证只保留格式良好的UTF-8.该库通过限制你创建`String`和`str`值的方式以及可以对它们执行的操作来确保这一点,这样在引入时值就是格式良好的,并且在你使用它们时保持这样.他们所有的方法都保护了这个保证:没有安全操作可以引入格式错误的UTF-8.这简化了与文本一起使用的代码.

Rust将文本处理方法放在`str`和`String`上,具体取决于方法是否需要可调整大小的缓冲区,或者只是使用文本就可以了.由于`String`解引用`&str`,因此`str`上定义的每个方法也可以在`String`上直接使用.本节介绍两种类型的方法,按粗略函数分组.

这些方法按字节偏移量索引文本,并以字节为单位测量其长度,而不是字符.实际上,考虑到Unicode的性质,按字符索引并不像看起来那么有用,字节偏移更快更简单.如果你试图使用一个位于某个字符的UTF-8编码中间的字节偏移量,该方法会发生恐慌,因此你不能以这种方式引入格式错误的UTF-8.

`String`被实现为`Vec<u8>`的包装器,确保向量的内容始终是格式良好的UTF-8.Rust永远不会更改`String`以使用更复杂的表示,因此你可以假设`String`共享`Vec`的性能特征.

在这些解释中,以下变量具有给定的类型:

|变量|推定类型|
|:--|:--|
|`string`|`String`|
|`slice`|`&str`或对其解引用的东西,如`String`或`Rc<String>`|
|`ch`|`char`|
|`n`|`usize`,长度|
|`i`,`j`|`usize`,字节偏移量|
|`range`|`usize`字节偏移量范围,或者完全限制为`i..j`,或者部分地限制为`i..`,`..j`,或`..`|
|`pattern`|任何模式类型:`char`,`String`,`&str`,`&[char]`,或`FnMut(char) -> bool`|

我们在第402页的"搜索文本的模式(Patterns for Searching Text)"中描述模式类型.

### 创建字符串值(Creating String Values)

有几种常见的方法可以创建`String`值:

- `String::new()`返回一个新的空字符串.它没有堆分配的缓冲区,但将根据需要分配一个缓冲区.

- `String::with_capacity(n)`返回一个新的空字符串,其中预分配的缓冲区至少保存`n`个字节.如果你知道预先构建的字符串的长度,则此构造函数允许你从一开始就正确地获取缓冲区大小,而不是在构建字符串时调整缓冲区的大小.如果字符串的长度超过`n`个字节,字符串仍然会根据需要增长缓冲区.与向量一样,字符串具有`capacity`,`reserve`和`shrink_to_fit`方法,但通常默认的分配逻辑很好.

- `slice.to_string()`分配一个新的`String`,其内容是`slice`的副本.我们在本书中一直使用像`"literal text".to_string()`这样的表达式来从字符串字面量中创建`String`.

- `iter.collect()`通过连接迭代器的项来构造字符串,这些项可以是`char`.`&str`或`String`值.例如,要从字符串中删除所有空格,你可以编写:

```Rust
let spacey = "man hat tan";
let spaceless: String =
    spacey.chars().filter(|c| !c.is_whitespace()).collect();
assert_eq!(spaceless, "manhattan");
```

使用`collect`这种方式利用了`String`的`std::iter::FromIterator`trait的实现.

- `&str`类型无法实现`Clone`:trait需要在`&T`上`clone`以返回`T`值,但`str`是无大小的.但是,`&str`确实实现了`ToOwned`,它允许实现者指定其拥有的等价物,因此`slice.to_owned()`返回`slice`的副本作为新分配的`String`.

### 简单检查(Simple Inspection)

这些方法从字符串切片获取基本信息:

- `slice.len()`是`slice`的长度,以字节为单位.

- `slice.is_empty()`,如果`slice.len() == 0`,则为`true`.

- `slice[range]`返回借用给定`slice`部分的切片.部分有界和无界范围都可以:例如:

```Rust
let full = "bookkeeping";
assert_eq!(&full[..4], "book");
assert_eq!(&full[5..], "eeping");
assert_eq!(&full[2..4], "ok");
assert_eq!(full[..].len(), 11);
assert_eq!(full[5..].contains("boo"), false);
```

- 你不能使用单个位置索引字符串切片,如`slice[i]`.在给定的字节偏移处获取单个字符有点笨拙:你必须在切片上生成`char`迭代器,并要求它解析一个字符的UTF-8:

```Rust
let parenthesized = "Rust (饂)";
assert_eq!(parenthesized[6..].chars().next(), Some('饂'));
```

但是,你应该很少需要这样做.Rust有更好的方法来迭代切片,我们在第403页的"迭代文本(Iterating over Text)"中对此进行了描述.

- `slice.split_at(i)`返回从`slice`借来的两个共享切片的元组:直到字节偏移量`i`的部分,以及它后面的部分.换句话说,这返回`(slice[..i], slice[i..])`.

- `slice.is_char_boundary(i)`,如果字节偏移量`i`落在字符边界之间,则为`true`,因此适合作为切片的偏移量.

当然,切片可以比较相等性,是有序的和可哈希的.有序比较只是将字符串视为`Unicode`代码点序列,并按字典顺序对它们进行比较.

### 追加和插入文本(Appending and Inserting Text)