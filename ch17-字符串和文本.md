# 字符串和文本

> 字符串是一个刻板的数据结构,在任何地方传递它都有很多重复的过程.它是隐藏信息的完美工具.
> --Alan Perlis,  epigram #34

原文

> The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
> --Alan Perlis, epigram #34

在本书中,我们一直在使用Rust的主要文本类型,`String`,`str`和`char`.在第64页的"字符串类型(String Types)"中,我们描述了字符和字符串字面量的语法,并展示了字符串在内存中的表示方式.在本章中,我们将更详细地介绍文本处理.

在这一章当中:

- 我们为你提供有关Unicode的背景知识,可帮助你了解标准库的设计.

- 我们描述了`char`类型,表示单个Unicode代码点.

- 我们描述`String`和`str`类型,表示拥有和借用的Unicode字符序列.它们有各种用于构建,搜索,修改和迭代其内容的方法.

- 我们涵盖Rust的字符串格式化工具,如`println!`和`format!`宏.你可以编写自己的宏来处理格式化字符串,并扩展它们以支持你自己的类型.

- 我们概述了Rust的正则表达式支持.

- 最后,我们讨论为什么Unicode规范化很重要,并展示如何在Rust中执行它.

## 一些Unicode背景知识(Some Unicode Background)

这本书是关于Rust的,而不是Unicode,它已经有很多关于它的书了.但Rust的字符和字符串类型是围绕Unicode设计的.以下是一些有助于解释Rust的Unicode.

### ASCII,Latin-1,和Unicode(ASCII, Latin-1, and Unicode)

Unicode和ASCII匹配所有ASCII的代码点,从`0`到`0x7f`:例如,两者都为字符`'*'`分配代码点`42`.类似地,Unicode将`0`到`0xff`分配给与ISO/IEC 8859-1字符集相同的字符,这是用于西欧语言的ASCII的8位超集.Unicode将此范围的代码点称为 *Latin-1代码块(Latin-1 code block)* ,因此我们将通过更令人回味的名称 *Latin-1* 来引用ISO/IEC 8859-1.

由于Unicode是Latin-1的超集,因此将Latin-1转换为Unicode甚至不需要表:

```Rust
fn latin1_to_char(latin1: u8) -> char {
    latin1 as char
}
```

假设代码点落在Latin-1范围内,反向转换也是微不足道的:

```Rust
fn char_to_latin1(c: char) -> Option<u8> {
    if c as u32 <= 0xff {
        Some(c as u8)
    } else {
        None
    }
}
```

### UTF-8

Rust的`String`和`str`类型使用UTF-8编码形式表示文本.UTF-8将字符编码为1到4个字节的序列(图17-1).

*图17-1. UTF-8编码*

对格式良好的UTF-8序列有两个限制.首先,只考虑任何给定代码点的最短编码;你不能花四个字节来编码一个适合三个的代码点.此规则确保给定代码点只有一个UTF-8编码.其次,格式良好的UTF-8不能编码从`0xd800`到`0xdfff`或超过`0x10ffff`的数字:这些数字要么保留用于非字符目的,要么完全在Unicode范围之外.

图17-2显示了一些示例.

*图17-2. UTF-8示例*

请注意,即使蟹表情符号(carb emoji)的编码,其前导字节仅对代码点贡献零,它仍然需要四字节编码:三字节UTF-8编码只能传送16位代码点,而`0x1f980`是17位长.

这是一个字符串的快速示例,其中包含具有不同长度编码的字符:

```Rust
assert_eq!("うどん: udon".as_bytes(),
           &[0xe3, 0x81, 0x86, // う
             0xe3, 0x81, 0xa9, // ど
             0xe3, 0x82, 0x93, // ん
             0x3a, 0x20, 0x75, 0x64, 0x6f, 0x6e // : udon
           ]);
```

该图显示了UTF-8的一些非常有用的属性:

- 由于UTF-8将代码点`0`到`0x7f`编码为不超字节`0`到`0x7f`,因此保存ASCII文本的字节范围是有效的UTF-8.如果UTF-8字符串仅包含ASCII字符,则反之亦然:UTF-8编码是有效的ASCII.

对于Latin-1也不是这样:例如,Latin-1将`'é'`编码为字节`0xe9`,UTF-8将其解释为三字节编码的第一个字节.

- 通过查看任何字节的高位.你可以立即判断它是某个字符的UTF-8编码的开头,还是来自其中一个字节.

- 编码的第一个字节单独通过其前导位告诉你编码的全长.

- 由于编码不超过四个字节,因此UTF-8处理永远不需要无界循环,这在处理不可信的数据时很好.

- 在格式良好的UTF-8中,即使从字节中间的随机点开始,你也可以可以清楚地知道字符编码的开始和结束位置.UTF-8的第一个字节和后面的字节总是不同的,因此一个编码不能在另一个编码中间开始.第一个字节确定编码的总长度,因此没有编码可以是另一个的前缀.这有很多好的结果.例如,在UTF-8字符串中搜索ASCII分隔符字符只需要对分隔符的字节进行简单扫描.它永远不会出现在多字节编码的任何部分,因此根本不需要跟踪UTF-8结构.类似地,在另一个字节串中搜索一个字节字符串的算法将在不修改UTF-8字符串的情况下工作,即使有些算法甚至不检查正在搜索的文本的每个字节.

尽管可变宽度编码比固定宽度编码更复杂,但这些特性使得UTF-8的使用比你预期的更加舒适.标准库为你处理大多数方面.

### 文本方向性(Text Directionality)

而拉丁语,西里尔语和泰语等手稿是从左到右书写的,其他手稿如希伯来语和阿拉伯语则是从右到左书写的.Unicode按照通常写入或读取的顺序存储字符,因此保存希伯来语文本的字符串的初始字节编码将在右侧写入的字符:

```Rust
assert_eq!("ערב טוב".chars().next(), Some('ע'));
```

标准库中的一些方法名称使用术语`left`和`right`来表示文本的开头和结尾.当我们描述这些函数时,我们将详细说明他们实际做了什么.

## 字符(char)(Characters (char))

Rust`char`是一个包含Unicode代码点的32位值.保证`char`在`0`到`0xd7ff`的范围内,或者在`0xe000`到`0x10ffff`的范围内;所有创建和操作`char`值的方法都确保这是真的.`char`类型实现了`Copy`和`Clone`,以及用于比较,哈希和格式化的所有常用trait.

在下面的描述中,变量`ch`始终是`char`类型.

### 字符分类(Classifying Characters)

`char`类型具有将字符分类为几个常见类别的方法.这些都是从Unicode中得出它们的定义,如表17-0所示.

|方法|描述|示例|
|:--|:--|:--|
|`ch.is_numeric()`|一个数字字符.这包括Unicode常规类别"Number;digit"和"Number;letter",但不是"Number;other".|`'4'.is_numeric()`<br/>`'ᛮ'.is_numeric()`<br/>`!'⑧'.is_numeri()`|
|`ch.is_alphabetic()`|字母字符:Unicode的"字母(Alphabetic)"派生属性.|`'q'.is_alphabetic()`<br/>`'七'.is_alphabetic()`|
|`ch.is_alphanumeric()`|数字或字母,如上所定义|`'9'.is_alphanumeric()`<br/>`'饂'.is_alphanumeric()`<br/>`!'*'.is_alphanumeric()`|
|`ch.is_whitespace()`|空白字符:Unicode字符属性"WSpace=Y".|`' '.is_whitespace()`<br/>`'\n'.is_whitespace()`<br/>`'\u{A0}'.is_whitespace()`|
|`ch.is_control()`|控制字符:Unicode的"Other,control"常规类别.|`'\n'.is_control()`<br/>`'\u{85}'.is_control()`|

### 处理数字(Handling Digits)

对于处理数字,你可以使用以下方法:

- `ch.to_digit(radix)`决定`ch`是否为基数`radix`的数字.如果是,则返回`Some(num)`,其中`num`是`u32`.否则,它返回`None`.这仅识别ASCII数字,而不识别`char::is_numeric`所涵盖的更广泛的字符类.`radix`参数的范围为2到36.对于大于10的基数,任一情况的ASCII字母都被视为数字,值为10到35.

- 如果可能,自由函数`std::char::from_digit(num, radix)`将`u32`数字值`num`转换为`char`.如果`num`可以用`radix`表示为单个数字,`from_digit`返回`Some(ch)`,其中`ch`是数字.当`radix`大于10时,`ch`可以是小写字母.否则,它返回`None`.

这与`to_digit`相反.如果`std::char::from_digit(num, radix)`是`Some(ch)`,则`ch.to_digit(radix)`是`Some(num)`.如果`ch`是ASCII数字或小写字母,则反之亦然.

- `ch.is_digit(radix)`,如果`ch`是基数`radix`的ASCII数字,则返回`true`.这相当于`ch.to_digit(radix) != None`.

所以,例如:

```Rust
assert_eq!('F'.to_digit(16), Some(15));
assert_eq!(std::char::from_digit(15, 16), Some('f'));
assert!(char::is_digit('f', 16));
```

### 字符的大小写转换(Case Conversion for Characters)

处理字符案例:

- `ch.is_lowercase()`和`ch.is_uppercase()`指示`ch`是小写字母还是大写字母.它们遵循Unicode的小写(Lowercase)和大写(Uppercase)派生属性,因此它们涵盖非拉丁字母表,如希腊语和西里尔语,并为ASCII提供预期的结果.

- `ch.to_lowercase()`和`ch.to_uppercase()`返回根据Unicode默认大小写转换算法生成`ch`等效的大写和小写字符的字符的迭代器:

```Rust
let mut upper = 's'.to_uppercase();
assert_eq!(upper.next(), Some('S'));
assert_eq!(upper.next(), None);
```

这些方法返回迭代器而不是单个字符,因为Unicode中的大小写转换并不总是一对一的过程:

```Rust
// The uppercase form of the German letter "sharp S" is "SS":
let mut upper = 'ß'.to_uppercase();
assert_eq!(upper.next(), Some('S'));
assert_eq!(upper.next(), Some('S'));
assert_eq!(upper.next(), None);

// Unicode says to lowercase Turkish dotted capital 'İ' to 'i'
// followed by `'\u{307}'`, COMBINING DOT ABOVE, so that a
// subsequent conversion back to uppercase preserves the dot.
let ch = 'İ'; // `'\u{130}'`
let mut lower = ch.to_lowercase();
assert_eq!(lower.next(), Some('i'));
assert_eq!(lower.next(), Some('\u{307}'));
assert_eq!(lower.next(), None);
```

为方便起见,这些迭代器实现了`std::fmt::Display`trait,因此你可以将它们直接传递给`println!`或`write!`宏.

### 转换为整数和从整数转换(Conversions to and from Integers)

Rust的`as`运算符将`char`转换为任何整数类型,静默掩盖任何高位:

```Rust
assert_eq!('B' as u32, 66);
assert_eq!('饂' as u8, 66);   // upper bits truncated
assert_eq!('二' as i8, -116); // same
```

`as`运算符将任何`u8`值转换为`char`,而`char`也实现`From<u8>`,但更宽的整数类型可以表示无效的代码点,因此对于那些必须使用`std::char::from_u32`,它返回`Option<char>`:

```Rust
assert_eq!(char::from(66), 'B');
assert_eq!(std::char::from_u32(0x9942), Some('饂'));
assert_eq!(std::char::from_u32(0xd800), None); // reserved for UTF-16
```

### String和str(String and str)

Rust的`String`和`str`类型保证只保留格式良好的UTF-8.该库通过限制你创建`String`和`str`值的方式以及可以对它们执行的操作来确保这一点,这样在引入时值就是格式良好的,并且在你使用它们时保持这样.他们所有的方法都保护了这个保证:没有安全操作可以引入格式错误的UTF-8.这简化了与文本一起使用的代码.

Rust将文本处理方法放在`str`和`String`上,具体取决于方法是否需要可调整大小的缓冲区,或者只是使用文本就可以了.由于`String`解引用`&str`,因此`str`上定义的每个方法也可以在`String`上直接使用.本节介绍两种类型的方法,按粗略函数分组.

这些方法按字节偏移量索引文本,并以字节为单位测量其长度,而不是字符.实际上,考虑到Unicode的性质,按字符索引并不像看起来那么有用,字节偏移更快更简单.如果你试图使用一个位于某个字符的UTF-8编码中间的字节偏移量,该方法会发生恐慌,因此你不能以这种方式引入格式错误的UTF-8.

`String`被实现为`Vec<u8>`的包装器,确保向量的内容始终是格式良好的UTF-8.Rust永远不会更改`String`以使用更复杂的表示,因此你可以假设`String`共享`Vec`的性能特征.

在这些解释中,以下变量具有给定的类型:

|变量|推定类型|
|:--|:--|
|`string`|`String`|
|`slice`|`&str`或对其解引用的东西,如`String`或`Rc<String>`|
|`ch`|`char`|
|`n`|`usize`,长度|
|`i`,`j`|`usize`,字节偏移量|
|`range`|`usize`字节偏移量范围,或者完全限制为`i..j`,或者部分地限制为`i..`,`..j`,或`..`|
|`pattern`|任何模式类型:`char`,`String`,`&str`,`&[char]`,或`FnMut(char) -> bool`|

我们在第402页的"搜索文本的模式(Patterns for Searching Text)"中描述模式类型.

### 创建字符串值(Creating String Values)

有几种常见的方法可以创建`String`值:

- `String::new()`返回一个新的空字符串.它没有堆分配的缓冲区,但将根据需要分配一个缓冲区.

- `String::with_capacity(n)`返回一个新的空字符串,其中预分配的缓冲区至少保存`n`个字节.如果你知道预先构建的字符串的长度,则此构造函数允许你从一开始就正确地获取缓冲区大小,而不是在构建字符串时调整缓冲区的大小.如果字符串的长度超过`n`个字节,字符串仍然会根据需要增长缓冲区.与向量一样,字符串具有`capacity`,`reserve`和`shrink_to_fit`方法,但通常默认的分配逻辑很好.

- `slice.to_string()`分配一个新的`String`,其内容是`slice`的副本.我们在本书中一直使用像`"literal text".to_string()`这样的表达式来从字符串字面量中创建`String`.

- `iter.collect()`通过连接迭代器的项来构造字符串,这些项可以是`char`.`&str`或`String`值.例如,要从字符串中删除所有空白,你可以编写:

```Rust
let spacey = "man hat tan";
let spaceless: String =
    spacey.chars().filter(|c| !c.is_whitespace()).collect();
assert_eq!(spaceless, "manhattan");
```

使用`collect`这种方式利用了`String`的`std::iter::FromIterator`trait的实现.

- `&str`类型无法实现`Clone`:trait需要在`&T`上`clone`以返回`T`值,但`str`是无大小的.但是,`&str`确实实现了`ToOwned`,它允许实现者指定其拥有的等价物,因此`slice.to_owned()`返回`slice`的副本作为新分配的`String`.

### 简单检查(Simple Inspection)

这些方法从字符串切片获取基本信息:

- `slice.len()`是`slice`的长度,以字节为单位.

- `slice.is_empty()`,如果`slice.len() == 0`,则为`true`.

- `slice[range]`返回借用给定`slice`部分的切片.部分有界和无界范围都可以:例如:

```Rust
let full = "bookkeeping";
assert_eq!(&full[..4], "book");
assert_eq!(&full[5..], "eeping");
assert_eq!(&full[2..4], "ok");
assert_eq!(full[..].len(), 11);
assert_eq!(full[5..].contains("boo"), false);
```

- 你不能使用单个位置索引字符串切片,如`slice[i]`.在给定的字节偏移处获取单个字符有点笨拙:你必须在切片上生成`char`迭代器,并要求它解析一个字符的UTF-8:

```Rust
let parenthesized = "Rust (饂)";
assert_eq!(parenthesized[6..].chars().next(), Some('饂'));
```

但是,你应该很少需要这样做.Rust有更好的方法来迭代切片,我们在第403页的"迭代文本(Iterating over Text)"中对此进行了描述.

- `slice.split_at(i)`返回从`slice`借来的两个共享切片的元组:直到字节偏移量`i`的部分,以及它后面的部分.换句话说,这返回`(slice[..i], slice[i..])`.

- `slice.is_char_boundary(i)`,如果字节偏移量`i`落在字符边界之间,则为`true`,因此适合作为切片的偏移量.

当然,切片可以比较相等性,是有序的和可哈希的.有序比较只是将字符串视为`Unicode`代码点序列,并按字典顺序对它们进行比较.

### 追加和插入文本(Appending and Inserting Text)

以下方法向`String`添加文本:

- `string.push(ch)`将字符`ch`追加到`string`末尾.

- `string.push_str(slice)`追加`slice`的全部内容.

- `string.extend(iter)`将迭代器`iter`生成的项追加到字符串中.迭代器可以生成`char`,`str`或`String`值.这些是`String`的`std::iter::Extend`实现:

```Rust
let mut also_spaceless = "con".to_string();
also_spaceless.extend("tri but ion".split_whitespace());
assert_eq!(also_spaceless, "contribution");
```

- `string.insert(i, ch)`在`string`中的字节偏移量`i`处插入单个字符`ch`.这需要在`i`之后移动任何字符以便为`ch`腾出空间,因此以这种方式构建字符串可能需要时间与字符串长度二次方.

- `string.insert_str(i, slice)`对`slice`执行相同操作,具有相同的性能警告.

`String`实现了`std::fmt::Write`,这意味着`write!`和`writeln!`宏可以将格式化文本追加到`String`:

```Rust
use std::fmt::Write;

let mut letter = String::new();
writeln!(letter, "Whose {} these are I think I know", "rutabagas")?;
writeln!(letter, "His house is in the village though;")?;
assert_eq!(letter, "Whose rutabagas these are I think I know\n\
                    His house is in the village though;\n");
```

因为`write!`和`writeln!`设计用于写到输出流,它们返回一个`Result`,如果你忽略,Rust就会抱怨.这段代码使用`?`运算符来处理它,但是写入`String`实际上是绝对可靠的,因此在这种情况下,调用`.unwrap()`也可以.
由于`String`实现了`Add<&str>`和`AddAssign<&str>`,你可以编写如下代码:

```Rust
let left = "partners".to_string();
let mut right = "crime".to_string();
assert_eq!(left + " in " + &right, "partners in crime");

right += " doesn't pay";
assert_eq!(right, "crime doesn't pay");
```

当应用于字符串时,`+`运算符通过值获取其左操作数,因此它实际上可以重用该`String`作为添加的结果.因此,如果左操作数的缓冲区足够大以保存结果,则不需要分配.

在一个不幸的缺乏对称性的情况下,`+`的左操作数不能是`&str`,所以你不能写:

```Rust
let parenthetical = "(" + string + ")";
```

你必须这样写:

```Rust
let parenthetical = "(".to_string() + string + ")";
```

但是,这种限制不鼓励从末尾向后构建字符串.这种方法表现不佳,因为文本必须重复地移向缓冲区的末尾.

然而,通过追加小块来从头到尾构建字符串是有效的.`String`表现得像向量的行为方式,当需要更大容量时,总是至少使其缓冲区的大小加倍.如第62页上的"一个元素一个元素地构建向量(Building Vectors Element by Element)"中所述,使得重新复制(recopying)开销与最终的大小成正比.即便如此,使用`String::with_capacity`来创建具有正确缓冲区大小的字符串以避免调整大小,并且可以减少对堆分配器的调用次数.

### 删除文本(Removing Text)

`String`有一些删除文本的方法(这些方法不会影响字符串的容量;如果需要释放内存,请使用`shrink_to_fit`):

- `string.clear()`将字符串重置为空字符串.

- `string.truncate(n)`丢弃字节偏移量`n`之后的所有字符,保留`string`的长度最多为`n`.如果`string`短于`n`个字节,则无效.

- `string.pop()`从`string`中删除最后一个字符(如果有),并将其作为`Option<char>`返回.

- `string.remove(i)`从字符串偏移`i`中删除字符并返回它,将任何后续字符向前移动.这需要时间与后续字符数线性.

- `string.drain(range)`返回给定字节索引范围内的迭代器,并在删除迭代器后删除字符.范围后的字符向前移动:

```Rust
let mut choco = "chocolate".to_string();
assert_eq!(choco.drain(3..6).collect::<String>(), "col");
assert_eq!(choco, "choate");
```

如果你只想删除范围,可以立即删除迭代器,而不从中拉取任何项:

```Rust
let mut winston = "Churchill".to_string();
winston.drain(2..6);
assert_eq!(winston, "Chill");
```

### 搜索和迭代约定(Conventions for Searching and Iterating)

Rust用于搜索文本和迭代文本的标准库函数遵循一些命名约定,以便更容易记住:

- 大多数操作从头到尾处理文本,但名称以`r`开头的操作从尾到头工作.例如,`rsplit`是`split`的从尾到头(end-to-start)版本.在某些情况下,改变方向不仅会影响值的生成顺序,还会影响值本身.有关此示例,请参见图17-3中的图表.

- 名称以`n`结尾的迭代器将自己限制为给定数量的匹配.

- 名称以`_indices`结尾的迭代器与它们通常的迭代值一起产生它们出现的切片中的字节偏移量.

标准库不为每个操作提供所有组合.例如,许多操作不需要`n`变量,因为它很容易提前结束迭代.

### 搜索文本的模式(Patterns for Searching Text)

当标准库函数需要搜索,匹配,拆分或修剪(trim)文本时,它会接受几种不同的类型来表示要查找的内容:

```Rust
let haystack = "One fine day, in the middle of the night";

assert_eq!(haystack.find(','), Some(12));
assert_eq!(haystack.find("night"), Some(35));
assert_eq!(haystack.find(char::is_whitespace), Some(3));
```

这些类型称为 *模式(patterns)* ,大多数操作都支持它们:

```Rust
assert_eq!("## Elephants"
           .trim_left_matches(|ch: char| ch == '#' || ch.is_whitespace()),
           "Elephants");
```

标准库支持四种主要模式:

- `char`作为模式,匹配该字符.

- `String`或`&str`或`&&str`作为模式,匹配等于模式的子字符串.

- `FnMut(char) -> bool`闭包作为模式,匹配闭包返回`true`的单个字符.

- `&[char]`作为模式(不是`&str`,而是`char`值的切片)匹配列表中出现的任何单个字符.请注意,如果将列表写为数组字面量,则可能需要使用`as`表达式来获取正确的类型:

```Rust
let code = "\t    function noodle() { ";
assert_eq!(code.trim_left_matches(&[' ', '\t'] as &[char]),
           "function noodle() { ");
// Shorter equivalent: &[' ', '\t'][..]
```

否则,Rust会被固定大小的数组类型`&[char; 2]`所迷惑,遗憾的是这不是模式类型.

在库自己的代码中,模式是实现`std::str::Pattern`trait的任何类型.`Pattern`的细节还不稳定,所以你不能在稳定(stable)的Rust中为你自己的类型实现它,但是在未来允许正则表达式和其他复杂模式的门是敞开的.Rust确保现在支持的模式类型将来继续有效.

### 搜索和替换(Searching and Replacing)

Rust有一些方法可以在切片中搜索模式,并可能用新文本替换它们:

- `slice.contains(pattern)`,如果`slice`包含`pattern`匹配,则返回`true`.

- `slice.starts_with(pattern)`和`slice.ends_with(pattern)`,如果`slice`的初始或最终文本与`pattern`匹配则返回`true`:

```Rust
assert!("2017".starts_with(char::is_numeric));
```

- `slice.find(pattern)`和`slice.rfind(pattern)`,如果`slice`包含`pattern`的匹配,返回`some(i)`,其中`i`是模式出现的字节偏移量.`find`方法返回第一个匹配,`rfind`最后一个匹配:

```Rust
let quip = "We also know there are known unknowns";
assert_eq!(quip.find("know"), Some(8));
assert_eq!(quip.rfind("know"), Some(31));
assert_eq!(quip.find("ya know"), None);
assert_eq!(quip.rfind(char::is_uppercase), Some(0));
```

- `slice.replace(pattern, replacement)`返回一个新的`String`,它通过用`replacement`替换所有匹配`pattern`而形成:

```Rust
assert_eq!("The only thing we have to fear is fear itself"
           .replace("fear", "spin"),
           "The only thing we have to spin is spin itself");

assert_eq!("`Borrow` and `BorrowMut`"
           .replace(|ch:char| !ch.is_alphanumeric(), ""),
           "BorrowandBorrowMut");
```

- `slice.replacen(pattern, replacement, n)`也是这样,但最多替换前`n`个匹配.

### 迭代文本(Iterating over Text)

标准库提供了几种迭代切片文本的方法.图17-3显示了一些示例.

你可以将`split`和`match`系列视为彼此的补充:拆分是匹配之间的范围.

*图17-3.一些迭代切片的方式*

对于某些类型的模式,从尾到头工作可以改变生成的值;例如,请参见图中`"rr"`模式的拆分.始终匹配单个字符的模式不能以这种方式运行.当迭代器在任一方向上生成相同的项的集时(也就是说,只有顺序受影响时),迭代器是`DoubleEndedIterator`,这意味着你可以应用其`rev`方法以其他顺序迭代,并从任意端拉取项:

- `slice.chars()`返回一个在`slice`的字符上的迭代器.

- `slice.char_indices()`返回`slice`字符及其字节偏移量的迭代器:

```Rust
assert_eq!("élan".char_indices().collect::<Vec<_>>(),
           vec![(0, 'é'), // has a two-byte UTF-8 encoding
                (2, 'l'),
                (3, 'a'),
                (4, 'n')]);
```

请注意,这不等同于`.chars().enumerate()`,因为它提供在切片内每个字符的字节偏移量,而不仅仅是对字符进行编号.

- `slice.bytes()`返回一个在`slice`的各个字节上的迭代器,公开UTF-8编码:

- `slice.lines()`返回`slice`行上的迭代器.行以`"\n"`或`"\r\ n"`结尾.生成的每个项都是从`slice`借来的`&str`.这些项目不包括行的终止字符.

- `slice.split(pattern)`返回切片由`pattern`匹配的分隔的部分上的迭代器.这会在紧邻的匹配之间产生空字符串,也会在`slice`的开头和结尾处匹配的产生.

- `slice.rsplit(pattern)`方法是相同的,但是从尾到头扫描`slice`,按顺序生成匹配.

- `slice.split_terminator(pattern)`和`slice.rsplit_terminator(pattern)`类似,不同之处在于模式被视为终结符,而不是分隔符:如果`pattern`在`slice`的右端匹配,则迭代器不会生成表示空字符串的切片,该匹配与切片末尾之间的空字符串,如`split`和`rsplit`一样.例如:

```Rust
// The ':' characters are separators here. Note the final "".
assert_eq!("jimb:1000:Jim Blandy:".split(':').collect::<Vec<_>>(),
           vec!["jimb", "1000", "Jim Blandy", ""]);

// The '\n' characters are terminators here.
assert_eq!("127.0.0.1  localhost\n\
            127.0.0.1  www.reddit.com\n"
            .split_terminator('\n').collect::<Vec<_>>(),
            vec!["127.0.0.1  localhost",
                 "127.0.0.1  www.reddit.com"]);
                 // Note, no final ""!
```

- `slice.splitn(n, pattern)`和`slice.rsplitn(n, pattern)`类似于`split`和`rsplit`,只是它们将字符串拆分为最多`n`个切片,在模式的第一个或最后`n-1`个匹配处.

- `slice.split_whitespace()`返回一个在`slice`的空白分隔部分上的迭代器.多个空白字符的运行被视为单个分隔符.尾随空白被忽略.这使用与`char::is_whitespace`相同的 *空白(whitespace)* 定义:

```Rust
let poem = "This  is  just  to say\n\
            I have eaten\n\
            the plums\n\
            again\n";

assert_eq!(poem.split_whitespace().collect::<Vec<_>>(),
           vec!["This", "is", "just", "to", "say",
                "I", "have", "eaten", "the", "plums",
                "again"]);
```

- `slice.matches(pattern)`返回切片中与`pattern`匹配的上迭代器.`slice.rmatches(pattern)`是相同的,但是从尾到头迭代.

- `slice.match_indices(pattern)`和`slice.rmatch_indices(pattern)`是相似的,只是生成的项是`(offset, match)`对,其中`offset`是匹配开始的字节偏移量,`match`是匹配的切片.

### Trimming(Trimming)

*trim* 字符串是从字符串的开头或结尾删除文本,通常是空白.它通常用于清理文件中的输入读取,其中用户可能为了易读性而缩进文本,或者意外地在行上留下尾随空格.

- `slice.trim()`返回`slice`的子切片,省略任何前导和尾随空格.`slice.trim_left()`仅省略前导空格,`slice.trim_right()`仅尾随空格:

```Rust
assert_eq!("\t*.rs  ".trim(), "*.rs");
assert_eq!("\t*.rs  ".trim_left(), "*.rs  ");
assert_eq!("\t*.rs  ".trim_right(), "\t*.rs");
```

- `slice.trim_matches(pattern)`返回`slice`的子切片,它从开头和结尾省略了`pattern`的所有匹配. `trim_left_matches`和`trim_right_matches`方法仅对前导或尾随匹配执行相同操作:

```Rust
assert_eq!("001990".trim_left_matches('0'), "1990");
```

请注意,这些方法名称中的术语`left`和`right`分别始终指切片的开头和结尾,而不管它们保存的文本的方向性如何.

### 字符串的大小写转换(Case Conversion for Strings)

方法`slice.to_uppercase()`和`slice.to_lowercase()`返回一个新分配的字符串,其中包含转换为大写或小写的`slice`文本.结果可能与切片的长度不同;有关详细信息,请参见第396页的"字符大小写转换(Case Conversion for Characters)".

### 从字符串解析其他类型(Parsing Other Types from Strings)

Rust为从字符串中解析值和生成值的文本表示都提供了标准`trait`.

如果类型实现了`std::str::FromStr`trait,那么它提供了一种从字符串切片中解析值的标准方式:

```Rust
pub trait FromStr: Sized {
    type Err;
    fn from_str(s: &str) -> Result<Self, Self::Err>;
}
```

所有常见的机器类型都实现了`FromStr`:

```Rust
use std::str::FromStr;

assert_eq!(usize::from_str("3628800"), Ok(3628800));
assert_eq!(f64::from_str("128.5625"), Ok(128.5625));
assert_eq!(bool::from_str("true"), Ok(true));

assert!(f64::from_str("not a float at all").is_err());
assert!(bool::from_str("TRUE").is_err());
```

`std::net::IpAddr`类型,一个包含IPv4或IPv6互联网地址的`enum`,也实现了`FromStr`:

```Rust
use std::net::IpAddr;

let address = IpAddr::from_str("fe80::0000:3ea9:f4ff:fe34:7a50")?;
assert_eq!(address,
           IpAddr::from([0xfe80, 0, 0, 0, 0x3ea9, 0xf4ff, 0xfe34, 0x7a50]));
```

字符串切片有一个`parse`方法,可以将切片解析为你喜欢的任何类型,假设它实现了`FromStr`.与`Iterator::collect`一样,你有时需要拼出你想要的类型,因此`parse`并不总是比直接调用`from_str`更易读:

```Rust
let address = "fe80::0000:3ea9:f4ff:fe34:7a50".parse::<IpAddr>()?;
```

### 将其他类型转换为字符串(Converting Other Types to Strings)

将非文本值转换为字符串有三种主要方法:

- 具有自然人类可读打印形式的类型可以实现`std::fmt::Display`trait,它允许你在`format!`宏中使用`{}`格式说明符:

```Rust
assert_eq!(format!("{}, wow", "doge"), "doge, wow");
assert_eq!(format!("{}", true), "true");
assert_eq!(format!("({:.3}, {:.3})", 0.5, f64::sqrt(3.0)/2.0),
          "(0.500, 0.866)");

// Using `address` from above.
let formatted_addr: String = format!("{}", address);
assert_eq!(formatted_addr, "fe80::3ea9:f4ff:fe34:7a50");
```

所有Rust的机器数字类型都实现了`Display`,字符,字符串和切片也是如此.智能指针类型`Box<T>`,`Rc<T>`和`Arc<T>`实现`Display`,如果`T`本身实现:它们的显示形式只是它们的指示对象.像`Vec`和`HashMap`这样的容器没有实现`Display`,因为这些类型没有单一的自然人类可读形式.

- 如果一个类型实现了`Display`,标准库会自动为它实现`std::str::ToString`trait,当你不需要`format!`的灵活性时,它的唯一方法`to_string`可以更方便:

```Rust
// Continued from above.
assert_eq!(address.to_string(), "fe80::3ea9:f4ff:fe34:7a50")
```