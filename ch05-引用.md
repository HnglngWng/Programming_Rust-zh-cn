# 引用(References)

> Libraries cannot provide new inabilities.
> --Mark Miller

到目前为止,我们看到的所有指针类型--简单的`Box<T>`堆指针,以及指向`String`和`Vec`值内部的指针--都是拥有指针:当所有者被删除时,引用对象也随之删除.Rust还有被称为 *引用(references)* 的非拥有指针类型,这中指针对其引用的对象的生命周期没有影响.

事实上,它恰恰相反:引用必须永远不会超过它们引用的对象.你必须在代码中明确,任何引用都不可能超过它指向的值.为了强调这一点,Rust指的是创建对某些值的引用作为 *借用(borrowing)* 值:你借入的内容,最终必须返回给其所有者.

如果你在阅读"你必须在代码中明确"这句话时感到有点怀疑,那么你在优秀的公司里,引用本身并不特别--在底层,它们只是地址.但Rust保证他们安全的规则是新奇的;除了研究语言之外,你以前不会看到任何类似的东西.虽然这些规则是Rust的一部分,需要最大的努力来掌握,但它们预防的经典的,绝对日常的错误的广度是惊人的,它们对多线程编程的影响是解放性的.这又是Rust的激进赌注.

举个例子,让我们假设我们要建立一个表格,里面有很多凶残的文艺复兴时期艺术家以及他们的作品.Rust的标准库包含一个哈希表类型，所以我们可以这样定义我们的类型:

```Rust
use std::collections::HashMap;
type Table = HashMap<String, Vec<String>>;
```

换句话说,这是一个哈希表,它将`String`值映射到`Vec<String>`值,将艺术家的名字映射到它们作品的名字的列表.你可以使用`for`循环遍历`HashMap`的条目,因此我们可以编写一个函数来打印`Table`以进行调试:

```Rust
fn show(table: Table) {
    for (artist, works) in table {
        println!("works by {}:", artist);
        for work in works {
            println!("  {}", work);
        }
    }
}
```

构建和打印表格很简单:

```Rust
fn main() {
    let mut table = Table::new();
    table.insert("Gesualdo".to_string(),
                vec!["many madrigals".to_string(),
                    "Tenebrae Responsoria".to_string());
    table.insert("Caravaggio".to_string(),
                vec!["The Musicians".to_string(),
                    "The Calling of St. Matthew".to_string()]);
    table.insert("Cellini".to_string(),
                vec!["Perseus with the head of Medusa".to_string(),
                    "a salt cellar".to_string()]);
    show(table);
}
```

一切正常:

```Shell
$ cargo run
     Running `/home/jimb/rust/book/fragments/target/debug/fragments`
works by Gesualdo:
  Tenebrae Responsoria
  many madrigals
works by Cellini:
  Perseus with the head of Medusa
  a salt cellar
works by Caravaggio:
  The Musicians
  The Calling of St. Matthew
$
```

但是如果你已经阅读了前一章关于移动的章节,那么show的这个定义应该会引起一些问题.特别是,`HashMap`不是`Copy`--它也不能是,因为它拥有一个动态分配的表.因此,当程序调用`show(table)`时,整个结构将移动到函数,使变量`table`成为未初始化状态.如果调用代码现在尝试使用`table`,它将遇到麻烦：

```Rust
...
show(table);
assert_eq!(table["Gesualdo"][0], "many madrigals");
```

Rust抱怨`table`不再可用:

```Rust
error[E0382]: use of moved value: `table`
  --> references_show_moves_table.rs:29:16
   |
28 |     show(table);
   |          ----- value moved here
29 |     assert_eq!(table["Gesualdo"][0], "many madrigals");
   |                ^^^^^ value used here after move
   |
   = note: move occurs because `table` has type `HashMap<String, Vec<String>>`,
           which does not implement the `Copy` trait
```

实际上,如果我们研究`show`的定义,外部`for`循环将获取哈希表的所有权并完全消耗它;并且内部`for`循环对每个向量执行相同的操作.(我们之前在"liberté, égalité, fraternité"示例中看到了这种行为.)由于移动语义,我们只是通过尝试将其打印出来就完全破坏了整个结构.谢谢,Rust!

处理此问题的正确方法是使用引用.引用允许你访问一个值而不影响其所有权.引用有两种:

- *共享引用(shared reference)* 允许你读取但不能修改它引用的对象.但是,你可以一次拥有对特定值的任意多个共享引用.表达式`&e`产生对`e`值的共享引用;如果`e`具有类型`T`,那么`&e`具有类型`&T`,发音为"ref T".共享引用是`Copy`.

- 如果你有对值的 *可变引用(mutable reference)* ,则可以同时读取和修改该值.但是,你不可以同时有任何类型的任何其他的引用同时激活该值.表达式`&mut e`产生对`e`值的可变引用;类型写作`&mut T`,发音为"ref mute T".可变引用不是`Copy`.

你可以将共享引用和可变引用之间的区别视为在编译时强制执行 *多个读取器(multiple readers)* 或 *单个写入器(single writer)* 规则的方法.实际上,这条规则不仅适用于引用, 它也包括借来的值的所有者.只要存在对值的共享引用,即使其所有者也不可以修改它;该值被锁定.当`show`正在使用`table`时,没有人可以修改它.类似地,如果存在对值的可变引用,则它具有对该值的独占访问权;在可变引用消失之前,你根本不能使用所有者.保持共享和可变完全分离对内存安全至关重要,原因我们将在本章讨论.

我们的示例中的打印函数不需要修改表,只是读取其内容.因此调用者应该能够向表传递一个表的共享引用,如下所示：

```Rust
show(&table);
```

引用是非拥有指针,因此`table`变量仍然是整个结构的所有者;`show`只是借了一下.当然,我们需要调整`show`的定义来匹配,但你必须仔细观察才能看出差异:

```Rust
fn show(table: &Table) {
    for (artist, works) in table {
        println!("works by {}:", artist);
        for work in works {
            println!("  {}", work);
        }
    }
}
```

`show`的参数`table`的类型已从`Table`更改为了`&Table`:我们现在传递共享引用,而不是按值传递表(因此将所有权移动到函数中).这是唯一的文字变化.但是,当我们通过函数体时,这是如何发挥作用的?

虽然我们的原来的外部`for`循环取得了`HashMap`的所有权并使用了它,但在我们的新版本中它接收了对`HashMap`的共享引用.迭代对`HashMap`的共享引用被定义为生成对每个条目的键和值的共享引用:`artist`已从`String`变为`&String`,`work`从`Vec<String>`变为`&Vec<String>`.

内部循环也发生了类似的变化.迭代对向量的共享引用被定义为生成对其元素的共享引用,因此`work`现在是`&String`.在此函数的任何地方都没有所有权转手;它只是传递非拥有的引用.

现在,如果我们想编写一个函数来按字母顺序分析每个艺术家的作品,那么共享引用是不够的,因为共享引用不允许修改.相反,排序函数需要接收对表的可变引用:

```Rust
fn sort_works(table: &mut Table) {
    for (_artist, works) in table {
        works.sort();
    }
}
```

我们需要传递一个:

```Rust
sort_works(&mut table);
```

这种可变借用赋予`sort_works`读取和修改结构的能力,也是向量`sort`方法所需要的.

当我们以一种将值的所有权移动到函数的方式将值传递给函数时,我们说我们已经 *通过值(by value)* 传递了它.如果我们将对值的引用传递给函数,我们说我们*通过引用(by reference)* 传递了值.例如,我们修改了`show`函数,将其更改为通过引用而不是通过值接受表.许多语言都有这种区别,但它在Rust中尤其重要,因为它阐明了所有权如何受到影响.

## 引用作为值(References as Values)

前面的示例显示了一个非常典型的引用用法:允许函数访问或操作结构而不占用所有权.但是引用比这更灵活,所以让我们看一些例子来更详细地了解正在发生的事情.

### Rust引用对比C++引用(Rust References Versus C++ References)

如果你熟悉C++中的引用,它们确实与Rust引用有一些共同之处.最重要的是,在机器级别它们都只是地址.但在实践中,Rust的引用有着截然不同的感觉.

在C++中,引用是通过转换隐式创建的,也是隐式解引用:

```C++
// C++ code!
int x = 10;
int &r = x;             // initialization creates reference implicitly
assert(r == 10);        // implicitly dereference r to see x's value
r = 20;                 // stores 20 in x, r itself still points to x
```

在Rust中,使用`&`运算符显式创建引用,使用`*`运算符显式解引用:

```Rust
// Back to Rust code from this point onward.
let x = 10;
let r = &x;             // &x is a shared reference to x
assert!(*r == 10);      // explicitly dereference r
```

要创建可变引用,请使用`&mut`运算符：

```Rust
let mut y = 32;
let m = &mut y;        // &mut y is a mutable reference to y
*m += 32;              // explicitly dereference m to set y's value
assert!(*m == 64);     // and to see y's new value
```

但是你可能还记得,当我们修改`show`函数以通过引用而不是通过值来接收艺术家表时,我们却不必使用`*`运算符.这是为什么?

因为引用在Rust中如此广泛使用,所以,如果需要,`.`运算符隐式解引用其左操作数:

```Rust
struct Anime { name: &'static str, bechdel_pass: bool };
let aria = Anime { name: "Aria: The Animation", bechdel_pass: true };
let anime_ref = &aria;
assert_eq!(anime_ref.name, "Aria: The Animation");

// Equivalent to the above, but with the dereference written out:
assert_eq!((*anime_ref).name, "Aria: The Animation");
```

用在`show`函数中的`println!`宏展开的代码使用`.`运算符,因此它也利用了这种隐式解引用.

如果需要进行方法调用,`.`操作符还可以隐式借用其左操作数的引用.例如,`Vec`的`sort`方法接收对向量的可变引用,因此这里显示的两个调用是等价的:

```Rust
let mut v = vec![1973, 1968];
v.sort();           // implicitly borrows a mutable reference to v
(&mut v).sort();    // equivalent; much uglier
```

简而言之,C++在引用和左值(lvalues)(即引用内存中位置的表达式)之间隐式转换,这些转换出现在任何需要的位置,在Rust中,你使用`&`和`*`运算符来创建和跟踪引用,`.`运算符例外,它隐式地借用和解引用.

### 给引用赋值(Assigning References)

给Rust引用赋值使它指向一个新值:

```Rust
let x = 10;
let y = 20;
let mut r = &x;

if b { r = &y; }

assert!(*r == 10 || *r == 20);
```

引用`r`最初指向`x`.但如果`b`为真,则代码将其指向`y`,如图5-1所示.

*图5-1. 引用r,现在指向y而不是x*

这与C++非常不同,C++给引用赋值将值存储在其引用中.没有办法将C++引用指向除初始化之外的位置.

### 引用的引用(References to References)

Rust允许引用的引用:

```Rust
struct Point { x: i32, y: i32 }
let point = Point { x: 1000, y: 729 };
let r: &Point = &point;
let rr: &&Point = &r;
let rrr: &&&Point = &rr;
```

(为了清楚起见,我们已经写出了引用类型,但是你可以省略它们:这里没有任何东西是Rust无法推断自己出来的)`.`运算符跟随同引用一样多来找到它的目标:

```Rust
assert_eq!(rrr.y, 729);
```

在内存中,引用的排列如图5-2所示.

*图5-2. 引用的引用链*

因此,由`rrr`类型引导的表达式`rrr.y`,实际上在获取`Point`的`y`字段之前遍历三个引用才到达它.

### 比较引用(Comparing References)

像`.`运算符一样,Rust的比较运算符"透视'任意数量的引用,只要两个操作数具有相同的类型:

```Rust
let x = 10;
let y = 10;

let rx = &x;
let ry = &y;

let rrx = &rx;
let rry = &ry;

assert!(rrx <= rry);
assert!(rrx == rry);
```

这里的最终断言成功,即使`rrx`和`rry`指向不同的值(即`rx`和`ry`),因为`==`运算符跟随所有引用并对其最终目标`x`和`y`执行比较.这几乎总是你想要的行为,尤其是在编写泛型函数时.如果你真的想知道两个引用是否指向同一个内存,你可以使用`std::ptr::eq,它们将它们作为地址进行比较:

```Rust
assert!(rx == ry);              // their referents are equal
assert!(!std::ptr::eq(rx, ry)); // but occupy different addresses
```

### 引用永不为空(References Are Never Null)

Rust引用永远不会为空.没有和C的`NULL`或C++的`nullptr`类似的东西;引用没有默认初始值(在初始化之前不能使用任何变量,无论其类型如何);和Rust不会将整数转换为引用(`unsafe`代码除外),因此你无法将零转换为引用.

C和C++代码通常使用空指针来指示缺少值:例如,`malloc`函数返回指向新内存块的指针,如果没有足够的可用内存来满足请求,则返回`nullptr`.在Rust中,如果你需要的值是对某事物的引用或者没有,请使用类型`Option<&T>`.在机器级别,Rust表示`None`作为空指针,而`Some(r)`,其中`r`是一个`&T`值,作为非零地址,因此`Option<&T>`与C或C++中的可空指针一样高效,尽管它更安全:它的类型要求你在使用之前检查它是否为None.

### 借用对任意表达式的引用(Borrowing References to Arbitrary Expressions)

虽然C和C++只允许将`&`运算符应用于某些类型的表达式,但Rust允许你借用对任何类型表达式的值的引用:

```Rust
fn factorial(n: usize) -> usize {
    (1..n+1).fold(1, |a, b| a * b)
}
let r = &factorial(6);
assert_eq!(r + &1009, 1729)
```

在这种情况下,Rust只是创建一个匿名变量来保存表达式的值,并使引用指向该值.这个匿名变量的生命周期取决于你对引用的处理方式:

- 如果你立即在`let`语句中给引用赋值为变量(或使它成为一些立即赋值的结构或数组的一部分),那么Rust就会使匿名变量活得和`let`初始化的变量一样长.在前面的例子中,Rust会为`r`的引用对象执行此操作.

- 否则,匿名变量活到封闭语句的结束.在我们的示例中,为保存`1009`而创建的匿名变量仅持续到`assert_eq!`语句的结束.

如果你习惯使用C或C++,这可能听起来容易出错.但请记住,Rust永远不会让你编写会产生悬空引用的代码.如果引用可以在匿名变量的生命周期之外使用,Rust将始终在编译时向你报告该问题.然后,你可以修复代码,将引用对象保存在具有适当生命周期的命名变量中.

### 切片和Trait对象的引用(References to Slices and Trait Objects)

到目前为止,我们展示的引用都是简单的地址.然而.Rust还包含两种 *胖指针(fat pointers)* ,两个字长的值带有一些值的地址,以及便于使用该值的必要信息.

对切片的引用是胖指针,其携带切片的起始地址及其长度.我们在第3章中详细描述了切片.

Rust的另一种胖指针是一个 *trait object* ,它是对实现特定trait的值的引用.trait对象携带一个值的地址和一个指向与该值相应的trait实现的指针,用于调用trait的方法.我们将在第238页的"Trait Object"中详细介绍trait对象.

除了携带这些额外的数据之外,切片和trait对象引用的行为就像我们在本章中到目前为止所展示的其他类型的引用一样：它们不拥有它们的引用对象;它们不能比它们的引用对象活得更久,它们可能是可变的或共享的;等等.

## 引用安全性(Reference Safety)

正如我们到目前为止所介绍的,引用看起来非常像C或C++中的普通指针.但那些是不安全的;Rust如何控制其引用?也许了解规则的最佳方式是试图打破它们.我们将从最简单的示例开始,然后添加有趣的复杂性并解释它们是如何工作的.

### 借用局部变量(Borrowing a Local Variable)

这是一个非常明显的例子.你不能借用对局部变量的引用并将其从变量的作用域中取出：

```Rust
{
    let r;
    {
        let x = 1;
        r = &x;
    }
    assert_eq!(*r, 1);  // bad: reads memory `x` used to occupy
}
```

Rust编译器拒绝此程序,并带有详细的错误消息:

```Rust
error: `x` does not live long enough
  --> references_dangling.rs:8:5
   |
7  |         r = &x;
   |              - borrow occurs here
8  |     }
   |     ^ `x` dropped here while still borrowed
9  |     assert_eq!(*r, 1);  // bad: reads memory `x` used to occupy
10 | }
   | - borrowed value needs to live until here
```

Rust抱怨,`x`只活到内部块结束,而引用则活到外部块结束.这使其成为一个悬空指针,这是禁止的.

虽然对于一个人类读者来说很明显,这个程序是坏的.但是值得一看的是Rust自己是如何得出这个结论的.即使这个简单的例子也显示了Rust用来检查更复杂代码的逻辑工具.

Rust尝试为程序中的每个引用类型分配一个 *生命周期(lifetime)* ,该生命周期满足使用方式所施加的约束.生命周期是程序的一些范围,可以安全地使用引用:词法块,语句,表达式,某些变量的作用域等.生命周期完全是Rust的编译时想象力的虚构.在运行时,引用只不过是一个地址;它的生命周期是其类型的一部分,没有运行时表示.

在这个例子中,有三个生命周期,我们需要理清它们之间的关系.变量`r`和`x`各有一个生命周期,从它们初始化的点延伸到它们超出作用域的点.第三个生命周期是引用类型的生命周期:我们借用到`&x`的引用类型,并存储在`r`中.