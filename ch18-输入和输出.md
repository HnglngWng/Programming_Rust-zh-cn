# 输入和输出(Input and Output)

> 杜利特尔:你有什么具体证据表明你存在吗?
炸弹 #20:嗯...嗯......我思故我在.
杜利特尔:很好.非常好.但是你怎么知道别的东西存在呢?
炸弹 #20:我的感官装置向我展示了它.
> --Dark Star

原文

> Doolittle: What concrete evidence do you have that you exist?
Bomb #20: Hmmmm...well...I think, therefore I am.
Doolittle: That’s good. That’s very good. But how do you know that anything else exists?
Bomb #20: My sensory apparatus reveals it to me.
> --Dark Star

Rust的输入和输出标准库功能围绕三个trait组织--`Read`,`BufRead`和`Write`--以及实现它们的各种类型:

- 实现`Read`的值具有面向字节的输入的方法.它们被称为 *读取器(readers)*.

- 实现`BufRead`的值是 *缓冲(buffered)* 读取器.它们支持`Read`的所有方法,还有读取文本行的方法等.

- 实现`Write`的值支持面向字节和UTF-8文本输出.它们被称为 *写入器(writers)*.

图18-1显示了这三个trait以及读写器类型的一些示例.

在本章中,我们将展示如何使用这些trait及其方法,各种实现它们的类型,以及与文件,终端和网络交互的其他方式.

*图18-1. 从Rust标准库中选择的读取器和写入器类型*

## 读取器和写入器(Readers and Writers)

*读取器(Readers)* 是程序可以从中读取字节的值.例子包括:

- 使用`std::fs::File::open(filename)`打开的文件.

- `std::net::TcpStream`,用于通过网络接收数据.

- `std::io::stdin()`,用于从进程的标准输入流中读取.

- `std::io::Cursor<&[u8]>`值,它们是从已经在内存中的字节数组"读取(read)"的读取器.

*写入器(Writers)* 是程序可以写入字节的值.例子包括:

- 使用`std::fs::File::create(filename)`打开的文件.

- `std::net::TcpStream`,用于通过网络发送数据.

- `std::io::stdout()`和`std::io::stderr()`,用于写入终端.

- `std::io::Cursor<&mut [u8]>`值,它允许你将任何可变的字节切片视为用于写入的文件.

- `Vec<u8>`,一个`writer`方法附加到向量的写入器.

由于读取器和写入器有标准的traits(`std::io::Read`和`std::io::Write`),因此编写适用于各种输入或输出通道的泛型代码是很常见的.例如,这是一个将从任何读取器的所有字节复制到任何写入器器的函数:

```Rust
use std::io::{self, Read, Write, ErrorKind};

const DEFAULT_BUF_SIZE: usize = 8 * 1024;

pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W)
    -> io::Result<u64>
    where R: Read, W: Write
{
    let mut buf = [0; DEFAULT_BUF_SIZE];
    let mut written = 0;
    loop {
        let len = match reader.read(&mut buf) {
            Ok(0) => return Ok(written),
            Ok(len) => len,
            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,
            Err(e) => return Err(e),
        };
        writer.write_all(&buf[..len])?;
        written += len asu64;
    }
}
```
