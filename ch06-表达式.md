# 表达式(Expressions)

> LISP程序员知道一切的价值,却对代价一无所知.
> --Alan Perlis, epigram #55

原文

> LISP programmers know the value of everything, but the cost of nothing.
> --Alan Perlis, epigram #55

在本章中,我们将介绍Rust的 *表达式(expressions)* ,它是构成Rust函数体的积木.一些概念(如闭包和迭代器)足够深入,我们稍后将专门用一章来介绍它们.现在,我们的目标是在几页中涵盖尽可能多的语法.

## 一个表达式语言(An Expression Language)

Rust在视觉上类似于C语言家族,但这有点像诡计.在C中, *表达式(expressions)* ,看起来像这样的代码:

```C
5 * (fahr-32) / 9
```

和 *语句(statements)* ,看起来更像这样:

```C
for (; begin != end; ++begin) {
    if (*begin == target)
        break;
}
```

之间有明显的区别.

表达式有值.语句没有.

Rust是所谓的 *表达式语言(expression language)*.这意味着它遵循较古老的传统,可追溯到Lisp,其中表达式完成所有工作.

在C中,`if`和`switch`是语句.它们不会产生值,也不能在表达式中使用它们.在Rust中,`if`和`match` *可以(can)* 产生值.我们已经在第2章中看到了一个产生数值的`match`表达式:

```Rust
pixels[r * bounds.0 + c] =
    match escapes(Complex { re: point.0, im: point.1 }, 255) {
        None => 0,
        Some(count) => 255 - count as u8
    };
```

`if`表达式可用于初始化变量:

```Rust
let status =
    if cpu.temperature <= MAX_TEMP {
        HttpStatus::Ok
    } else {
        HttpStatus::ServerError  // server melted
};
```

`match`表达式可以作为参数传递给函数或宏:

```Rust
println!("Inside the vat, you see {}.",
    match vat.contents {
        Some(brain) => brain.desc(),
        None => "nothing of interest"
    });
```

这解释了为什么Rust没有C的三元运算符(`expr1 ? expr2: expr3`).在C语言中,它是`if`语句的一个方便的表达式类似物.在Rust中它是多余的:`if`表达式处理两种情况.

C中的大多数控制流工具都是语句.在Rust中,它们都是表达式.

## 块和分号(Blocks and Semicolons)

块也是表达式.块生成一个值,可以在需要值的任何地方使用:

```Rust
let display_name = match post.author() {
    Some(author) => author.name(),
    None => {
        let network_info = post.get_network_metadata()?;
        let ip = network_info.client_address();
        ip.to_string()
    }
};
```

`Some(author) =>`之后的代码是简单表达式`author.name()`.`None =>`之后的代码是块表达式.这对Rust来说没什么区别.块的值是其最后一个表达式`ip.to_string()`的值.

请注意,该表达式后面没有分号.大多数Rust代码行都以分号或大括号结尾,就像C或Java一样.如果一个块看起来像C代码,在所有熟悉的地方都有分号,那么它将像C块一样运行,其值将是`()`.正如我们在第2章中提到的,当你将分号放在块的最后一行时,你正在使该块产生一个值--最终表达式的值.

在某些语言中,特别是JavaScript,你可以省略分号,而语言就为你填写--这是一个小小的便利.这是不同的.在Rust中,分号实际上意味着什么.

```Rust
let msg = {
// let-declaration: semicolon is always required
let dandelion_control = puffball.open();

// expression + semicolon: method is called, return value dropped
    dandelion_control.release_all_seeds(launch_codes);

// expression with no semicolon: method is called,
// return value stored in `msg`
    dandelion_control.get_status()
};
```

块的这种能力,包含声明并在最后产生一个值是一个很好的功能,很快就会感觉很自然.一个缺点是,当你意外地遗漏分号时,它会导致奇怪的错误消息.

```Rust
...
if preferences.changed() {
    page.compute_size()  // oops, missing semicolon
}
...
```

如果你在C或Java程序中犯了这个错误,编译器只会指出你漏掉了一个分号.这是Rust说的:

```Rust
error[E0308]: mismatched types
  --> expressions_missing_semicolon.rs:19:9
   |
19 |         page.compute_size()  // oops, missing semicolon
   |         ^^^^^^^^^^^^^^^^^^^ expected (), found tuple
   |
   = note: expected type `()`
              found type `(u32, u32)`
```

Rust假定你故意省略了这个分号;它没有考虑它只是一个错字的可能性.结果是一个混乱的错误消息.当你看到``expected type `()` ``时,首先查找缺少的分号.

块中也允许 *空语句(Empty statements)* .空语句由一个游离的分号组成,就是它本身:

```Rust
loop {
    work();
    play();
    ;        // <-- empty statement
}
```

Rust允许这样做,遵循C的传统.除了传达轻微的忧郁感之外,空语句什么都不做.我们只是为了完整性而提到它们.

## 声明(Declarations)

除了表达式和分号之外,块还可以包含任意数量的声明.最常见的是`let`声明,它声明了局部变量:

```Rust
let name: type = expr;
```

类型和初始化器是可选的.分号是必需的.

`let`声明可以在不初始化的情况下声明变量.然后可以使用稍后的赋值初始化变量.这偶尔会有用,因为有时变量应该从某种控制流结构的中间初始化:

```Rust
let name;
if  user.has_nickname() {
    name = user.nickname();
} else {
    name = generate_unique_name();
    user.register(&name);
}
```

这里有两种不同的方式可以初始化局部变量`name`,但无论哪种方式,它都只将被初始化一次,因此`name`不需要声明为`mut`.

在变量初始化之前使用变量是错误的.(这与移动后使用值的错误密切相关.Rust真的希望你只在它们存在时使用值!)

你可能偶尔会看到似乎重新声明现在变量的代码,如下所示:

```Rust
for line in file.lines() {
    let line = line?;
    ...
}
```

这相当于:

```Rust
for line_result in file.lines() {
    let line = line_result?;
    ...
}
```
